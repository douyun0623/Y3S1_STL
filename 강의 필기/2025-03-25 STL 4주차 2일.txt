2025-03-25 STL 4주 2일

RAII - 자원의 생명주기를 개체의 생명주에 동기화!!!!!!

오늘의 주제~~~~~~~~~~~~~~~
Callable : named requirements -> 이에 대해서 찾아볼것!
Callable type - 호출가능한 타입 

대표적으로 함수 함수말고도 여러개가 있나보다? -> 이것이 stl의 핵심

________________________________________________________________________________
// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

1000만개가 알려져있고 고정되어있다면 
data로 전역변수로 만드는것이 좋을것이다. 


default_random_engine dre;
uniform_int_distribution uid{ 0, 10 }; --> 10까지 출력되는 것인가? 10이 포함이 되는 것이다!!!


RAII -> 내가 for을 쓰고 하는것은 반성을 해보자 

// 앞에서 부터 1000개를 화면 출력
for (int i = 0; i < 1000; ++i)
	print("{:8}", a[i]);
cout << endl;

---> 낡은 루프 

#include <ranges>

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;


| 이는 필터라고 한다. 

// 앞에서 부터 1000개를 화면 출력
for (int num : a | views::take(1000)
				 | views::take(1)
	)
	print("{:8}", num);
cout << endl;

이러면 하나만 찍힘


void*  :  이 자료가 무슨 형식인지 모르겠어 오름차순아 너는 알잖아 너가 맘대로 타입을 바꿔도 상관없어! 라는 의미이다. 


________________________________________________________________________________
퀵소트
qsort(a.data(), a.size(), sizeof(int), 오름차순);

generic function 이다. 왜냐 c언어의 대표 함수이다. c언어이면서 generic함수인것임
generic이 뭐야? : 자료형에 무관함

사전에 약속된건 지켜야한다.  -> contiguous메모리만 할수 있다구	
						array<int, 10000000> a;
						전역변수니까  DATA에 저장된다.

						시작 번지는 a.data()에 있어~
						전체의 메모리의 크기는? a.size()
						sizeof(int)는 정식 아님 (이건 제네릭하지 않음) stl의 정식 표기는 
							->sizeof(array<int,10000000>::value_type)
							자료구조에게 물어보는것임 직접


contiguous 메모리를 랜덤하게 accesss할수있게 된다.
어떤 2개의 원소를 가져오는데 걸리는 시간이 O(1)이다.

정렬 방법도 generic하다!
정렬 방법은 무궁무진하다!

qsort는 contiguous 메모리의 정보를 2개를 뽑아서 이 2개의 값을 바꿔야해 말아야해?
정렬방법에게 물어본다.


1000만개가 있다면 오릅차순에게 NlogN물어봐야 끝난다.
A,B는 어떻게 뽑아서 

qsort/sort가  quick sort는 아님



내림차순(descending order)


정렬기준 = 오름차순;
정렬기준 = 내림차순;
이와 같이 바꾸고 중간에 바꾸려면 함수 포인터를 써서 바꿔줄수 있다. 


	int xxx;
	int yyy = (int)xxx;

오름차순의 데이터 타입
 (int(*)(const void*, const void*))오름차순;



________________________________________________________________________________
int a[1000];  => array <int, 1000> a;

// 이것도 개선 가능
int(*정렬기준)(const void*, const void*) 
				=> (			) 정렬기준;
			나중에 배움


정렬기준은 함수포인터이다. -> 이는 몇바이트야? 예는 포인터니까 8바이트야
stack에 생기는 포인터야~




			
	___________
	|		|				정렬기준
	|		|code				8바이트
	|___________|			statck 에서 오름차순의 주소가 들어가있다. 
	|qsort()
	|___________|
qsort |stl
	|___________
	|<-
오름차순|return <>
	|
	|
	|
			


save의 저장됭어있는 
(*save)("메인.cpp");이게 정식 함수코드야~
약식 호출방법 save("메인.cpp");
save의 시작번지에 넣는거야



Design Pattern
->component
singleton -> 이건 사용하는게 아니다.. 제대로 알면 빠꾸

돌아가는길을 찾는거야





qsort => c언어 (안쓰는거임 이런..)


________________________________________________________________________________
// 정렬 contiguous
sort(a.begin(), a.end()); 				a.data()
얘한테 전달된 정보를 보는거야		________________________________
							|  |					  |  배열 뒷공간전달
				원소 맨앞전달	a[0] a.begin


이것으로 모든것을 파악할 수 있다. 
-> 근데 왜 오름차순으로 정렬됐어? -> 기본이 오름차순 정렬임
	디폴트 정렬 operator < 이를 이용해서 정렬



함수를 직접 썼을떄 보다 
람다를 썼을때 시간이 더 적게 걸린다...
람다는 뭐야? 이름 없는 함수 -> 왜 람다를 쓰지? 호출하는 시간이 준다? 전혀 그렇지 않다. 
람다의 정체를 다음시간에 알아보자
이런 얘기를 다음 시간에 계속한다. 



DATA 영역
CODE 영역에 오름차순, 람다 다 적혀 있다....  code에 적혀있지 않아도될 가능성이 있다..?



sort<array<int,10000000>::iterator>(a.begin(), a.end(), 오름차순);	이것이 정식 호출형태
	-> 이것이 바로 시간이 이런 이유



