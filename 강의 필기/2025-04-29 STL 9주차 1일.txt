2025-04-29 STL 9주차 1일

기말은 처음부터 모두 코딩해야할거임
클래스도


중간고사 답
!!

1.
	// 이유는 ?
	// 1부터 100까지의 데이터를 적은 것임
	// 파일을  text모드로 열었어 기록하게 되면 특정 아스키 캐릭터에 대해서 변환이 일어난다. 
	// 특정 캐릭터는 01이고 01이 10114이렇게 변하죠
	// 그래서 답을
	// 바이트 변환이 일어난다.


2.
	read 를 따로 만들지 않아야함
	기말에는 문제

	friend istream& operator>>(istream& is, Test& t) {
	is.read((char*)&t.num, sizeof(int));
	t.p = make_unique<int[]>(t.num);
	is.read((char*)t.p.get(), sizeof(int) * t.num);
	return is;
	}
	이렇게 써야함

array<Test, 2'000> a;

for (Test& t : a)
	in >> t;

a.back().show();

num 값 : 46


// 벡터를 썼다?

vector<Test> v;

Test t;
in >> t;
v.push_back(move(t));
왜 되는지 설명해야할거다.



3. 


// sort는 a.begin()에서 정렬할 type 정보를 알 수 있다.
// 1. less<type>{};		기본정렬에 사용할 함수객체를 이용하여 정렬한다.
// 2. bool operator<(const type&, const type& rhs) 정렬한다.
// 3. bool Test::operator<(const type& rhs) 로 정렬한다.
// 1,2,3 다 없으면 컴파일 오류
적어야하면 이런것을 써야한다. 이번 시험에는 안적어도 괜찮았다.

bool operator<(const Test& rhs) const {
	return num < rhs.num;
}
이렇게 const를 쓴순간 멤버일 수밖에 없다.

bool operator<(const Test& rhs) const {
	return this->num < rhs.num;
}

여기서 this->num이런것을 할 필요가 없음
안붙여도 되는데 왜 그런거지?


a.back().show();
이렇게 해서 답을 num 값 : 234



4.


for (Test& t : a)
	cout << t.average() << endl;


accumulate의 더 나은 버전 reduce 여기선 쓸 필요 없겠지


double average() const {
	return accumulate(p.get(), p.get() + num, 0LL) / static_cast<double>(num);
}


그냥 double(num) 해도 상관은 없다.



5. 


	long long sum{};
	long long cnt{};
	for (int i = numeric_limits<int>::min(); i < numeric_limits<int>::max(); ++i) {
		sum += to_string(i).length();
		++cnt;
	}
	sum += numeric_limits<int>::max();
	++cnt;
	cout << "합계 - " << sum << endl;
	cout << "평균 - " <<	format("{:.2f}", (double)sum / cnt)	<< endl;


합산 평균 69.4


기말 시험 vector<STRING> v{ "1", "22", "333", "4444", "55555" };
이걸 그림 그릴 수 있어야한다. 


erase(v, "333");

식택틱 슈가

vector<STRING> v{ "1", "22", "333", "4444", "55555" };

관찰 = true;
erase(v, "333");
관찰 = false;

벡터에 이러는 순간 
너무 많은 과정이 일어난다.


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
list는 추가나 빼는 것이 O(1)걸린다.

어 근데 리스트로 했는데

list<STRING> v{ "1", "22", "333", "4444", "55555" };

관찰 = true;
erase(v, "333");
관찰 = false;


[      11] 생성자(char*)    자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2260
[      11] 소멸자           자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2260
[      12] 생성자(char*)    자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2230
[      12] 소멸자           자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2230
[      13] 생성자(char*)    자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2150
[      13] 소멸자           자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2150
[      14] 생성자(char*)    자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2170
[      14] 소멸자           자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e2170
[      15] 생성자(char*)    자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e21a0
[      15] 소멸자           자원수:3          메모리:0xd2b614fb30, 자원메모리:0x2352e2e21a0
[       8] 소멸자           자원수:3          메모리:0x2352e2e4130, 자원메모리:0x2352e2e2160

왜 이런건가?



list<STRING> v{ "1", "22", "333", "4444", "55555" };

관찰 = true;
erase(v, "333");
관찰 = false;


x64/ release 기계에서 
40바이트 이름 v 이 객체는 스택에 만들어진다.
v는 노드 기반이기 때문에 5개 만들어진다. 이 5개는 프리 스토어에 저장된다. 
말 그대로 프리해서 캐쉬 적중룰이 망함
프리스토어에 생성한 각자는 24바이트의 객체이다. 
객체 생성 번호를 살펴 보면 6 7 8 9 10 이렇게 정해진다.
이 객체는 시퀀셜 ~ 이기 때문에 서로 stack 객체 에서 6 이렇게 연결 된다. 쭉쭉
연결 하기 위해서 앞뒤를 연결하는 2개의 포인터가 있다. 어디를 가야하는지 가르켜야하기 때문이다.

근데 포인터만 쓱 옮기면 관찰 메시지가 뜨지 않아야하는거 아니야?
근데 다 뜨네
왜 벡터랑 똑같이 뜨지?



STL 이란
container + Agorithm
	iterator를 통해서 소통한다.

list라는 자료구조가 있다. list<STRING> 
erase()라는 Algorithm 이는 반복자 iterator로 

erase => syntactic sugar

STL의 기본 설계는 벽이 있다.
컨테이너와 알고리즘이 누군지 처다볼수 없게 벽을 친다.
서로 누군지 상관이 없어!!
333을 지우려면 순차적으로 검색을 해야할거다.
333을 발견 -> 이는 없어져야할 데이터니까 2개를 땡겨야 하겠구나?

알고리즘은 장박뒤에 있는 컨테이너가 있느지 모르니까 이 컨테이너의 특성을 이용한 것을 쓸 수 가 없어

erase(remove(list.begin(), list.end(), "333")

operator == 
어떤 해결책을 써야할까?????
여기서는 답이 없어
자료구조의 특별한 알고리즘은 container에서 해야하는거야
잘할 수 있는 놈이 직접 제공하는 것이 합당하다!!!



v.remove("333");
아까와 다른 모습을 볼 수 있다. 
[      11] 생성자(char*)    자원수:3          메모리:0x7e7f6ffc90, 자원메모리:0x266b87d2700
[       8] 소멸자           자원수:3          메모리:0x266b87d42c0, 자원메모리:0x266b87d28a0 (8번 객체가 지워지는 동작)
[      11] 소멸자           자원수:3          메모리:0x7e7f6ffc90, 자원메모리:0x266b87d2700




벡터와 덱을 비교 설명!

vector<STRING> v;		->  단일 contiguous memory
deque<STRING> d;		-> block으로 연결한 contigous memory


그림 설명을 더 해보자면
벡터는 string 1000개를 담고 싶다면 하나의 빈 공간 없이 인덱스0부터 9999까지 제공하는 것이 벡터야
덱한테 1000개 요청한다면 
	0|1|2|4|	|4|5|6|7|		9101112  	이런 식으로 메모리를 유지 관리 한다. 

	9996|9997|9998|9999		이를 리스트처럼 관리한다. (이중 연결 리스트)

	객체를 블럭으로 묶어서 이중연결 리스트 
	
덱은 사기를 친다ㅏ. 
 v[500]	-> O(1)
d[500]  이 친구는 가짜 그러면서도 제공하다니 뻔뻔하다.(나도 랜덤 access가 가능해 라고 주장하는거야)

[] 연산자를 제공한다고 : 이름은 뭔가? (  어레이 오퍼레이터 , 서브 ~)
					배열 연산자 이를 제공한다는 의미는
				메모리가 contiguous하다는 의미를 가지고 있다. 


 [ ] => contiguous
	access 시간이 O(1)이 되도록 하는 거지용

근데 이는 왜 만들었어 (덱을 왜 만들었어)
동적으로 메모리를 관리하는 친구들이고

memory manger에게 메모리 관리

예를 들어서 8gb가 있어 누가 메모리를 달라고 해 그러면 메모리 메니저는 
여기를 쓰라고 알려주고 
사용중인 메모리의 목록을 마크 해둔다. 이는 (연결 리스트로 ) 테이블로 유지해도 되고 어떻게 해도 된다.

누가 또 요청을 했다. 메모리 매니저에게 요청하는 메모리는 항상 컨티구어스 메모리에요
이러면 무슨일이 발생하냐
메모리가 사용한 공간과 사용하지 않은 공간이 ~~~
최대한의 메모리 공간을 만드려는 동작은 한다 (메모리 메니저가)
벡터는 단독으로 크게 주고 벡터는 중간에 쓰고 있으면 크게 요청을 해야해서 fail
근데 공간을 최대한 써서 쓸 수 있다 deque은 
덱은 push_front  얼마든지 가능하다. 이 만큼을 블럭으로 만들고 연결한다.

결론! : 벡터와 덱이 있다면 경쟁하는 관계라면 누가 어떤 면에서 유리한가?
vector가 덱보다 access 속도가 우승!
어떤 원소를 더 많이 담을 수 있을까 덱이 더 많이 담을 가능성이 더 높다.1!!!

vector 1000이라면 deque은 1500개는 가능할 거다.

그다음단계 극단으로 내려오면 list가 있는거다
메모리 블럭이 점점 작아진다.
									|1 ... N|	|123| |567| 			1 2 3 ... N							
stl 컨테이너는 3가지로 분리						단일, 	  여러개 블럭, 리스트는 Node
1. sequence	지금은 이것들은 살펴보고 있었다. ( array, vector deque, list (foward_list 빠짐)
								고정사이즈, 나머지는 모두 free_store에서 관리(다이나믹)
							
2. associate
3. unordered associate 



알고리즘에서 가장 중요한것은 sort! (google이 이걸로 돈 범 )

sort의 기본 전제는 메모리가 붙어서  랜덤 access해야 가능하다. 
덱도 가능하지만 느리다.
list도 sort를 무지하게 잘한다고 (경우에 따라서)

벡터 sort 할때는 swap 동작이 일어난다. 
list도 화살표만 바꾸면 빠르다
어떤 것만 신경쓰면 되냐 list.sort() 이것만 생각하면 되겠다. (list의 특별한 동작 이 자료구조에서 더 잘 다루는 친구니까 직접 가지고 있다. !)




!!!!!!!!!!!!!!!!!1
list의 초기화
관찰 = true;
list<STRING> cont{ "1", "333", "55555", "4444", "22" };


관찰 = false;

[       1] 생성자(char*)    자원수:1          메모리:0x159beffb70, 자원메모리:0x17c3c585900
[       2] 생성자(char*)    자원수:3          메모리:0x159beffb88, 자원메모리:0x17c3c585910
[       3] 생성자(char*)    자원수:5          메모리:0x159beffba0, 자원메모리:0x17c3c5859e0
[       4] 생성자(char*)    자원수:4          메모리:0x159beffbb8, 자원메모리:0x17c3c585a40
[       5] 생성자(char*)    자원수:2          메모리:0x159beffbd0, 자원메모리:0x17c3c5858d0
[       6] 복사생성자       자원수:1          메모리:0x17c3c5846f0, 자원메모리:0x17c3c585920
[       7] 복사생성자       자원수:3          메모리:0x17c3c584a20, 자원메모리:0x17c3c5859d0
[       8] 복사생성자       자원수:5          메모리:0x17c3c584450, 자원메모리:0x17c3c5858e0
[       9] 복사생성자       자원수:4          메모리:0x17c3c5848d0, 자원메모리:0x17c3c585a50
[      10] 복사생성자       자원수:2          메모리:0x17c3c584690, 자원메모리:0x17c3c585930
[       5] 소멸자           자원수:2          메모리:0x159beffbd0, 자원메모리:0x17c3c5858d0
[       4] 소멸자           자원수:4          메모리:0x159beffbb8, 자원메모리:0x17c3c585a40
[       3] 소멸자           자원수:5          메모리:0x159beffba0, 자원메모리:0x17c3c5859e0
[       2] 소멸자           자원수:3          메모리:0x159beffb88, 자원메모리:0x17c3c585910
[       1] 소멸자           자원수:1          메모리:0x159beffb70, 자원메모리:0x17c3c585900



ranges::sort(cont.begin(), cont.end());
이러면 안된다. 오류난다. ranges에서는 확실하게 안된다고 표시 되고 옛날 sort에서는 확인할 방법이 없어서
빨간줄이 뜨지 않는다. 

심각도	코드	설명	프로젝트	파일	줄	비표시 오류(Suppression) 상태	세부 정보
오류(활성)	E0304	인수 목록이 일치하는 오버로드된 함수 "std::ranges::_Sort_fn::operator()"의 인스턴스가 없습니다.	2025 STL	D:\3\stl\2025 STL\2025 STL\메인.cpp	28		



