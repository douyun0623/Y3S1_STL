2025-04-22 STL 8주차 1일



vector<STRING> v;		 v메모리	0
v.reserve(1'000);					1000	
							확보한 메모리 연결
							⬇️
						24바이트 * 1000개 메모리

						이러면 push_back O(1)

1000의 공간을 다 쓴다면
1500 이때 전체 이동, 복사를 해야함 (이럴려고 쓰는거임)


개수를 가변으로 할수 있는데 1000개는 안쓸거 같아 
이럴때 inplace_vector


array<int, 26> a;
초기화 해야할까?
스택에서 만든건 디폴트 초기화를 해야겠다



// [문제] v에서 3을 제거하라
remove(v.begin(), v.end(), 3);

3이라는 값이 있으면 제거 해줘

근데 결과가 이상하다
1,2,3,4,5 (v에 들어있던 값)
1 2 4 5 5 (3을 지우고 난 값)



vector<int> v{ 1,2,3,4,5 };			

// [문제] v에서 3을 제거하라
remove(v.begin(), v.end(), 3);


자료구조					
v									
원소 개수 5											
5개의 메모리 공간										
메모리 공간을 가르키는 포인터 -> |1 2 3 4 5|							


알고리즘 remove(반복자라는 객체를 전달, 지우고 싶은 value  전달
알고리즘은 벡터인지 리스트인지 관심이 없고
while (b != e){
	if(*b == 3)
		?
}
뒤에 있는 것을 땡겨야한다.
맨마지막으로 가면 아 여긴 처리해야할 값이 없어!
remove는 반환값이 있어 ( new end 위치를 반환한다.)

왜 이렇게 코딩되어 있나
알고리즘이 자료구조에 접근할 수 없기 때문이야
자료구조의 필드는 private하게 되어 있어

만약 알고리즘 원소의 개수가 40로 바꾼다면?
이러면 일관성이... 깨져버린다.
이러면 내 메모리도 40칸이 있어야하는데..?
알고리즘은 응답도 반복자로 한다.


이제 원소 개수 줄이는건 벡터가 줄여야해!
암막커튼이 잇다고 생각하면 좋다.


	auto new_end = remove(v.begin(), v.end(), 3);
	v.erase(new_end, v.end());
이러면 자기 자신의 사이즈를 조절할 수 있겠지?
이러면 일관성이 유지 된다.

v.erase(remove(v.begin(), v.end(), 3), v.end());
이렇게 더 많이 쓴다.
이는 이와 같이 부른다. erase-remove idiom

알고리즘은 자료구조의 필드를 건들수 없고
실제 지우는 동작은 자료구조에서 해야한다.

이래서 원칙을 깨는 것을 하나 만듬
이는 너무 많이 쓰는데 함수를 만들면 안돼?

// cpp20에서 제공되는 전역함수
// vector에서만 사용가능하다.
// 근데 이건 제일 싫어하는 코딩중 하나
원칙을 깨버린 함수이다.( 속에서는 위와 같이 생겼지만 포장을 이러헥 했다.)
erase(v, 3);


어떤 조건이 맞는 지 확인하려면
프레드킷
보통 람다로 코딩

아래와 같이 코딩
// [문제] v에서 홀수를 제거하라
	v.erase(remove_if(v.begin(), v.end(), [](int n) {
		return n & 1;
		}), v.end());


전역함수로
// [문제] v에서 홀수를 제거하라
erase_if(v, [](int n) {
	return n & 1;
	});
이와 같이 쓴다.





	vector<STRING> v{ "1", "2", "3", "4", "5" };

	// [문제] V에서 "3"을 제거하라.

	v.erase(remove(v.begin(), v.end(), "3"), v.end());

내가 너의 클래스에서
똑같아의 정의를 알야하 할수 있을 같아

bool STRING::operator==(STRING& rhs) const

똑같은지 확인해줄게 : https://en.cppreference.com/w/cpp/algorithm/equal


bool STRING::operator==(STRING& rhs) const
{
	return std::equal(&p[0], &p[len], &rhs.p[0]);
}


	erase(v, "3");
뭔지 모르겠는데 오류 
내가 직접수정해야함 진짜 왜 안되는지 모름



v.insert(v.begin() + 2, "3");
벡터에게 insert는 미친동작!

[       9] 생성자(char*)    자원수:1          메모리:0xf9448ffb90, 자원메모리:0x22400142690
[      10] 이동생성자       자원수:1          메모리:0x2240013b6c0, 자원메모리:0x22400142690
[      11] 이동생성자       자원수:1          메모리:0x2240013b690, 자원메모리:0x22400142650
[      12] 이동생성자       자원수:1          메모리:0x2240013b6a8, 자원메모리:0x22400142510
[      13] 이동생성자       자원수:1          메모리:0x2240013b6d8, 자원메모리:0x22400142530
[      14] 이동생성자       자원수:1          메모리:0x2240013b6f0, 자원메모리:0x22400142560
[       5] 소멸자           자원수:0          메모리:0x2240013ced0, 자원메모리:0x0
[       6] 소멸자           자원수:0          메모리:0x2240013cee8, 자원메모리:0x0
[       7] 소멸자           자원수:0          메모리:0x2240013cf00, 자원메모리:0x0
[       8] 소멸자           자원수:0          메모리:0x2240013cf18, 자원메모리:0x0
[       9] 소멸자           자원수:0          메모리:0xf9448ffb90, 자원메모리:0x0



요청이
2와 3사이에 원소가 들어가야해!
공간이 더 필요해
앞 2개를 이동혹은 복사?
새로만든 3객체를 가져오고 싶겠지? (inplace도 아니고 )
나머지도 이동해야겠제?
이러라고 만든 멤버가 아니야!!!!!!



3을 제거하는 동작도 쉬운 동작이 아니다.





v.emplace(++++v.begin(), "333");
이도 생성을 할때 그 위치에 생성을 시켜서 따로 객체를 생성안한다.



deque<T> - vector보다 더 많은 원소를 담을 수 있다



deque에 대ㅐㅎ서 알아보자!





시험문제는 vector까지

