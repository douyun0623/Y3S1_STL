//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::ofstream out{ "2025 1 STL 화56목78 강의저장.txt", std::ios::app };

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;
}//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, v.begin());
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator{ out });
}                                                   
//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();		// time_point를 얻는다, epoch
	std::cout << now << std::endl;


	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}
//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();		// time_point를 얻는다, epoch
	using namespace std::chrono_literals;
	std::cout << now + 9h << std::endl;


	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-06 오후 5:03:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			// time_point를 얻는다, epoch
	auto utc = std::chrono::system_clock::to_time_t(now);	// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "======================================" << '\n';
	out << '\n';

	out.imbue(old);		// 원래 locale로 복귀

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-06 오후 5:04:17 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			// time_point를 얻는다, epoch
	auto utc = std::chrono::system_clock::to_time_t(now);	// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "======================================" << '\n';
	out << '\n';

	out.imbue(old);		// 원래 locale로 복귀

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-11 오후 1:49:35 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] save 기능을 파일로 분리하라

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 1:51:25 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] save 기능을 파일로 분리하라

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
	save("save.h");
	save("save.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 1:51:25 화요일
======================================

//-----------------------------------------------------------------
// save.h											2025년 3월 11일
//-----------------------------------------------------------------


#pragma once
void save(std::string_view);

======================================
저장한 시간: 2025-03-11 오후 1:51:25 화요일
======================================

//-----------------------------------------------------------------
// save.cpp											2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수 입니다.
//-----------------------------------------------------------------


#include <string>
#include <fstream>
#include <iostream>
#include <filesystem>
#include <chrono>

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			// time_point를 얻는다, epoch
	auto utc = std::chrono::system_clock::to_time_t(now);	// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "======================================" << '\n';
	out << '\n';

	out.imbue(old);		// 원래 locale로 복귀

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-11 오후 1:57:22 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

void change(int& a, int& b);

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("메인.cpp");
}

void change(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

======================================
저장한 시간: 2025-03-11 오후 2:03:05 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

void change(int&, int&);

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("메인.cpp");
}

void change(int& a, int& b) 
{
	int temp{ a };
	a = b;
	b = temp;
}

======================================
저장한 시간: 2025-03-11 오후 2:13:14 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

template <typename T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

template <typename T>
class Dog {
private:
	T num;
public:
	Dog(T num) : num(num){}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
};

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:28:29 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

class Dog {
public:
	Dog(){}
	Dog(int num) : num(num) {}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
private:
	int num{};
};


void change(int& , int& );
void change(Dog&, Dog&);

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

void change(int& a, int& b) 
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) 
{
	Dog temp{ a };
	a = b;		
	b = temp;
}	

======================================
저장한 시간: 2025-03-11 오후 2:36:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] c++ 언어에서 change 함수는 몇 번이나 overlading 해야할까?
// --> c++ 언어의 자료형은 몇 개인가? --> 무한하다(만들수 있기 때문)

class Dog {
public:
	Dog(){}
	Dog(int num) : num(num) {}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
private:
	int num{};
};

template <class T>
void change(T&, T&);

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

template <class T>
void change(T& a, T& b) 
{
	T temp{ a };
	a = b;
	b = temp;
}

======================================
저장한 시간: 2025-03-11 오후 2:54:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] c++ 언어에서 change 함수는 몇 번이나 overlading 해야할까?
// --> c++ 언어의 자료형은 몇 개인가? --> 무한하다(만들수 있기 때문)

class Dog {
public:
	Dog(){}
	Dog(int num) : num(num) {}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
private:
	int num{};
};

template <class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		// 1. change(DOg, Dog);	있니?
		// 2. change(Dog&, Dog&); 동시에 존재시 (모호하다.)
		// 3. 컴파일러가 template을 이용하여 코드 생성
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:58:16 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<int> dis(0, 99);

//--------
int main()
//--------
{
	for (int i{}; i < 100; ++i) {
		cout << dis(gen) << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:58:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<int> dis(0, 99);

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i) {
		cout << dis(gen) << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:59:07 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<int> dis(0, 99);

//--------
int main()
//--------
{
	int rand_num[1000];

	for (int i{}; i < 1000; ++i) {
		rand_num[i] = dis(gen);
		cout << rand_num[i] << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 3:07:58 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9999999 };

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:36:32 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:37:50 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre{ random_device{}() };
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:38:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre{ random_device{}() };
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:42:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre{ random_device{}() };
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	// 내가 해본거
	int rand_num[1000]{};

	int max{};

	for (int i{}; i < 1000; ++i) {
		rand_num[i] = uid(dre);
		if (max < rand_num[i]) {
			max = rand_num[i];
		}
	}
	cout << max << endl;

	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:52:16 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	// T[N]
	int arr[1'000];

	for (int i = 0; i < 1000; ++i)
		arr[i] = uid(dre);

	int maxValue{numeric_limits<int>::min()};

	for (int i = 0; i < 1000; ++i) {
		if (maxValue < arr[i])
			maxValue = arr[i];
	}

	cout << "최댓값 - " << maxValue << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:11:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	array<int, 1'000> arr;			// T[N] --> array<T,N>

	for (int& num : arr)
		num = uid(dre);

	cout << "최댓값 - " << *max_element(arr.begin(), arr.end()) << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:25:15 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	print("{:80}", 20250311);

	/*for (int i = 0; i < 1'000; ++i)
		print("{:8}", uid(dre));*/

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:25:40 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	print("{:<80}", 20250311);

	/*for (int i = 0; i < 1'000; ++i)
		print("{:8}", uid(dre));*/

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:36:44 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	ofstream out{ "int 1000개.txt" };		// RAII
	

	for (int i = 0; i < 1'000; ++i)
		print(out, "{:8}", uid(dre));

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:39:48 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	ofstream out{ "int 1000개.txt" };		// RAII
	
	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		print(out, "{:8}", uid(dre));
		if (not(++cnt % 10))
			out << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:44:55 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	// 내가 쓴거
	ifstream in{ "int 1000개.txt" };

	string str;
	while (in >> str) {
		cout << str;
	}
	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:45:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	// 내가 쓴거
	ifstream in{ "int 1000개.txt" };

	string str;
	while (in >> str) {
		cout << str << endl;
	}
	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:52:22 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue{ numeric_limits<int>::min() };
	size_t cnt{ };

	while (in >> num) {
		++cnt;
		if (maxValue < num)
			maxValue = num;
	}
	cout << "읽은 개수 - " << cnt << endl;
	cout << "최댓값 - " << maxValue << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:58:55 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout << "최댓값 - " << *max_element(istream_iterator<int>{in}, {}) << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 5:05:25 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다. 
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라. (5분)

//--------
int main()
//--------
{
	// 내가 쓴거
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array <int, 1000> arr;

	for (int& data : arr) {
		int temp;
		in >> temp;
		data = temp;
	}

	print(":8", arr);

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 5:10:35 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다. 
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라. (5분)

//--------
int main()
//--------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array <int, 1000> a;
	int num;
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		a[i] = num;
	}

	for (int num : a) {
		print("{:8}", num);
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:34:10 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 랜덤 데이터를 생성하기
//							/  파일 텍스트로 기록하기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다. 
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라. (5분)

//--------
int main()
//--------
{
	random_device rd{};
	cout << "이 값은 추적 불가능" << endl;

	for (int i = 0; i < 100; ++i)
		cout << rd() << '\n';

	/*ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array <int, 1000> a;
	int num;
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		a[i] = num;
	}

	for (int num : a) {
		print("{:8}", num);
	}*/

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:45:52 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------
#include <iostream>
#include <bitset>
#include "save.h"
using namespace std;			

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//--------
int main()
//--------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32> binary = num;

	cout << " 2진수 -  " << binary << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:47:27 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------
#include <iostream>
#include <bitset>
#include "save.h"
using namespace std;

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//--------
int main()
//--------
{
	int num{ 0x01'02'03'04 };

	bitset<32> binary = num;

	cout << " 2진수 -  " << binary << endl;
	cout << "10진수 - " << num << endl;
	cout << "16진수 - " << hex << num << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:56:04 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:56:41 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a{};

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:57:24 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	a.fill(333);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:58:51 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	int i{};
	for (int num : a)
		num = ++i;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:59:25 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	int i{};
	for (int& num : a)
		num = ++i;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:01:03 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 1);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:01:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 123);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:13:39 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 1);

	// [문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:17:43 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 1);

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;

	// [문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로", ios::binary };
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:21:03 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array <int, 1000> a;
	a.fill(0x0a0a0a0a);

	// [문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로"};
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:36:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// 파일에 "int 10만개를 바이너리 모드 write함수로 기록" 에 10만개의 랜덤 int 값을 기록하자
// 이 int값은 메모리 크기 그대로 기록한다.
// 파일은 binary mode로 열자.

default_random_engine dre;

//--------
int main()
//--------
{
	ofstream out{ "int 10만개를 바이너리 모드 write함수로 기록", ios::binary };
	
	uniform_int_distribution uid{ numeric_limits<int>::min(), numeric_limits<int>::max() };

	for (int i = 0; i < 10'0000; ++i) {
		int num = uid(dre);
		out.write((char*)&num, sizeof(int));
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:59:01 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리 모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용했어)
// int값 10만개를 읽어서 메모리에 저장하라.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라
// 화면에 출력된 값도 답지에 적어라.


//--------
int main()
//--------
{
	ifstream in{ "int 10만개를 바이너리 모드 write함수로 기록", ios::binary };
	if (not in)
		return 20250318;

	array<int, 10'0000> a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:59:44 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리 모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용했어)
// int값 10만개를 읽어서 메모리에 저장하라.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라
// 화면에 출력된 값도 답지에 적어라.


//--------
int main()
//--------
{
	ifstream in{ "int 10만개를 바이너리 모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000> a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// -2147431498

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 3:02:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리 모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용했어)
// int값 10만개를 읽어서 메모리에 저장하라.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라
// 화면에 출력된 값도 답지에 적어라.


//--------
int main()
//--------
{
	ifstream in{ "int 10만개를 바이너리 모드 write함수로 기록", ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// -2147431498

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-27 오후 3:53:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬


	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 3:55:13 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬


	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(1000)
					 | views::take(1)
		)
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:17:01 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int, 1'000'0000>::value_type), 오름차순);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:17:52 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int, 1'000'0000>::value_type), 오름차순);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:20:55 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

int 내림차순(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 내림차순(descending order) 정렬
	qsort(a.data(), a.size(), sizeof(array<int, 1'000'0000>::value_type), 내림차순);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:32:45 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

int 내림차순(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	int(*정렬기준)(const void*, const void*) = (int(*)(const void*, const void*))오름차순;

	//정렬기준 = 내림차순;
	qsort(a.data(), a.size(), sizeof(int), 정렬기준);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:46:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬 
	sort(a.begin(), a.end());

	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:54:40 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬 
	sort(a.begin(), a.end(), 오름차순);		// 디폴트 정렬 operator <

	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:57:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					// 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;

	for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 5:01:02 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					// 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;
	cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	/*for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;*/

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 5:04:35 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
		sort(a.begin(), a.end(), 오름차순);					// 디폴트 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		// 정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b){
				return a > b;
			});					// 디폴트 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}


	/*for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;*/

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:37:35 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	// 람다는 도대체 무엇인가?

	cout << "람다의 정체 - " << typeid([ ]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}).name() << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:39:02 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	// 람다는 도대체 무엇인가?

	cout << "람다 1의 정체 - " << typeid([ ]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}).name() << endl;

	cout << "람다 2의 정체 - " << typeid([ ]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}).name() << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:50:18 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {
		cout << "나를 왜 불렀죠?" << endl;
	}
};
//--------
int main()
//--------
{
	Dog dog;

	dog();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:51:37 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {
		cout << "나를 왜 불렀죠?" << endl;
	}
};
//--------
int main()
//--------
{
	Dog dog;

	cout << typeid(dog).name() << endl;

	dog.operator()();		// dog();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:51:59 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	class Dog {
	public:
		void operator()() {
			cout << "나를 왜 불렀죠?" << endl;
		}
	};

	Dog dog;

	cout << typeid(dog).name() << endl;

	dog.operator()();		// dog();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:59:30 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	class Dog{
	public:
		bool operator()(const int a, const int b) {
			return a > b;
		}
	};

	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num;
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:59:54 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	// 내가 쓴거
	class Dog{
	public:
		bool operator()(const int a, const int b) {
			return a > b;
		}
	};

	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num;
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:09:58 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	class Dog {
	public:
		bool operator()(int a, int b) const {
			return a > b;
		}
	};
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num;
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:10:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	class Dog {
	public:
		bool operator()(int a, int b) const {
			return a > b;
		}
	};
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num << " ";
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:13:53 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.

	auto Dog = [](int a, int b) ->bool { return a > b; };

	sort(a.begin(), a.end(), Dog);

	for (int num : a)
		cout << num << " ";
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:27:14 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	auto p = [](int a, int b) {return a > b; };
	cout << boolalpha << p(3, 4) << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:39:08 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a', 'z' };
uniform_int_distribution uidNameLen{ 3, 30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//--------
int main()
//--------
{
	array<Dog, 10> dogs;

	for (const Dog& dog : dogs)
		dog.show();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:39:40 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a', 'z' };
uniform_int_distribution uidNameLen{ 3, 30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		cout << "설마 생성자가?" << endl;
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//--------
int main()
//--------
{
	array<Dog, 10> dogs;

	for (const Dog& dog : dogs)
		dog.show();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:45:33 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a', 'z' };
uniform_int_distribution uidNameLen{ 3, 30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 
// ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog)	{
//		return os << dog.id << " " << dog.name << " ";
// }


//--------
int main()
//--------
{
	ofstream out("Dog 십만마리");

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 3:06:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name;
	}
private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& d) {
		return in >> d.name >> d.id;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		in >> dog;
		dogs[i] = dog;
	}

	for (int i = 0; i < 10; ++i) {
		dogs[i].show();
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 3:07:02 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name << endl;
	}
private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& d) {
		return in >> d.name >> d.id;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	for (int i = 0; i < 10; ++i) {
		dogs[i].show();
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 3:09:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name << endl;
	}
private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& dog) {
		return in >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	for (int i = 0; i < 10; ++i) {
		dogs[i].show();
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:39:26 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name << endl;
	}
private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& dog) {
		return in >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	int num;
	string name;
	int cnt{};
	while (in >> num >> name) {
		println("[{:7}] --- {:12} {}", ++cnt, num, name);
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:46:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	//int num;
	//string name;
	//int cnt{};
	//while (in >> num >> name) {
	//	println("[{:7}] --- {:12} {}", ++cnt, num, name);
	//}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 : ";
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:56:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
	}
	size_t getNameLen() const {
		return name.length();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog dog1, const Dog dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:57:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}
	size_t getNameLen() const {
		return name.length();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog dog1, const Dog dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::take(1000))
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:59:32 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}
	size_t getNameLen() const {
		return name.length();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog dog1, const Dog dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::reverse)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 4:06:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}

	bool operator<(const Dog& other) const {
		return name.size() < other.name.size();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end());

	for (const Dog& dog : dogs | views::reverse)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 4:07:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}

	bool operator<(const Dog& other) const {
		return name.size() < other.name.size();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end());

	for (const Dog& dog : dogs | views::reverse)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 4:38:08 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class STRING {

};

//--------
int main()
//--------
{
	string s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 5:10:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
using namespace std;

class STRING {
public:
	STRING(const char* s) : len{ strlen(s) } {			// [] -> *로 collapsing
		p.reset();
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);		// DMA
	}
	
	size_t size() const {
		return len;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

	friend ostream& operator<<(ostream& os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 1:38:24 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;



//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:14:00 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수
	cout << s << endl;

	STRING t;
	t = s;

	STRING u = s;

	cout << t << endl;
	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:14:49 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수
	cout << s << endl;

	STRING t;
	t = s;

	STRING u = s;

	cout << t << endl;
	cout << u << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:37:26 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:38:50 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:40:10 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:49:56 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:51:09 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//--------
int main()
//--------
{
	STRING t = s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:53:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//--------
int main()
//--------
{
	cout << "메인시작" << endl;

	STRING t = s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:57:18 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//--------
int main()
//--------
{
	관찰 = false;

	cout << "메인시작" << endl;

	STRING t = s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:05:22 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };

	// 길이기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});

	for (const STRING& str : a) {
		cout << str << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:06:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };

	// 길이기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});

	관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:06:50 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };

	// 길이기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});

	관찰 = true;
	for (auto str : a) {
		cout << str << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:08:11 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };


	// 길이기준 오름차순 정렬하고 출력하라

	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});
	관찰 = false;
	
	for (const auto& str : a) {
		cout << str << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:12:09 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// 다음시잔 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << s << endl;
	cout << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 3:52:29 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	// 다음시잔 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 3:53:07 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	// 다음시잔 STRING도 이렇게 동작하게 하자
	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 3:53:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;

	// 다음시잔 STRING도 이렇게 동작하게 하자
	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:24:42 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);

// 	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:41:08 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);

 	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:43:27 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬

	// 출력
	for (auto str : a)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:44:19 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬

	// 출력
	관찰 = true;
	for (auto str : a)
		cout << str << endl;
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:44:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬

	// 출력
	관찰 = true;
	for (const auto& str : a)
		cout << str << endl;
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 5:01:00 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬
	sort(a.begin(), a.end(), [] (const STRING& lhs, const STRING& rhs){
		return lhs.size() < rhs.size();
	});

	// 출력
	for (const STRING& str : a)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 5:01:34 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬
	관찰 = true;
	sort(a.begin(), a.end(), [] (const STRING& lhs, const STRING& rhs){
		return lhs.size() < rhs.size();
	});
	관찰 = false;

	// 출력
	for (const STRING& str : a)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:19:12 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 0> a;

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:26:30 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 0> a;

	cout << "빈 어레이니? - " << boolalpha << a.empty() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:26:43 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 0> a;

	cout << "빈 어레이니? - "  << a.empty() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:29:04 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 5> a{ 1,2,3,4,5 };	// int a[5]; 

	for (int i = -10; i < 10; ++i) {
		cout << a[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:39:49 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,4 };			// {} 기호는 initializer-list

	for (int num : {1, 2, 3, 4, 5})
		cout << num << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:43:21 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3 };			// {} 기호는 initializer-list

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof v << endl;
	cout << "v의 주소 - " << addressof(v) << endl;
	cout << "v의 타입 - " << typeid(v).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:44:33 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} 기호는 initializer-list

//--------
int main()
//--------
{
	
	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof v << endl;
	cout << "v의 주소 - " << addressof(v) << endl;
	cout << "v의 타입 - " << typeid(v).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:45:40 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int>* p = new vector<int>{ 1,2,3 };			// {} 기호는 initializer-list

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof(*p) << endl;
	cout << "v의 주소 - " << addressof(*p) << endl;
	cout << "v의 타입 - " << typeid(*p).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:54:47 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int> v { 1,2,3 };

	// 반복자를 사용하여 access
	for (vector<int>::iterator i = v.begin(); i != v.end(); ++i)
		cout << *i << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:03:08 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int> v { 1,2,3 };

	// 반복자를 사용하여 access
	for (auto i = v.cbegin(); i != v.cend(); ++i)
		cout << *i << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:04:08 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int> v { 1,2,3 };

	// 반복자를 사용하여 access
	for (auto i = v.crbegin(); i != v.crend(); ++i)
		cout << *i << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:09:17 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하라.

//--------
int main()
//--------
{
	cout << "정수를 마음껏 입력하세요. ";
	vector<int> v{ istream_iterator<int>{cin}, {} };

	long long sum = accumulate(v.begin(), v.end(), 0LL);
	cout << "합계 - " << sum << endl;
	cout << "평균 - " << (double)sum / v.size() << endl;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:09:44 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하라.

//--------
int main()
//--------
{
	cout << "정수를 마음껏 입력하세요. ";
	vector<int> v{ istream_iterator<int>{cin}, {} };

	long long sum = accumulate(v.begin(), v.end(), 0LL);
	cout << "합계 - " << sum << endl;
	cout << "평균 - " << (double)sum / v.size() << endl;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 3:41:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 단어를 오름차순으로 정렬한 후 출력하라

//--------
int main()
//--------
{
	vector<std::string> v{ istream_iterator<string>{cin}, {} };			// 키보드입력시작/끝

	sort(v.begin(), v.end());			

	for (const std::string& str : v) {
		cout << str << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 3:50:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?

//--------
int main()
//--------
{
	vector<int> v;

	cout << "현재 원소 개수 - " << v.size() << endl;
	cout << "재할당하지 않고 담을 수 있는 최대 원소  개수 -	" << v.capacity() << endl;
	cout << "v가 관리하는 메모리 - " << v.data() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:02:56 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?

//--------
int main()
//--------
{
	vector<int> v;

	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량      - " << v.capacity() << endl;
	cout << "메모리    - " << v.data() << endl;

	v.push_back(1);

	cout << "원소를 한 개 추가한 후 v의 내용" << endl;
	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량      - " << v.capacity() << endl;
	cout << "메모리    - " << v.data() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:04:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?

//--------
int main()
//--------
{
	vector<int> v;

	for (int i = 0; i < 10; ++i) {
		cout << "----------------------------" << endl;
		cout << "원소 개수 - " << v.size() << endl;
		cout << "용량      - " << v.capacity() << endl;
		cout << "메모리    - " << v.data() << endl;

		v.push_back(i);
		cout << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:18:16 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	vector<int> v;

	size_t old = v.capacity();
	for (int i = 0; i < 10000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "원소 수 - " << v.size() << endl;
			cout << "용량    - " << v.capacity() << endl;
			old = v.capacity();
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:18:33 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	vector<int> v;

	size_t old = v.capacity();
	for (int i = 0; i < 10000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "용량    - " << v.capacity() << endl;
			old = v.capacity();
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:30:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.push_back(STRING{ "12345" });
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:37:08 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	STRING a{ "12345" };
	v.push_back(a);
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:38:22 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.push_back(static_cast<STRING&&>(STRING{ "12345" }));
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:44:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back(STRING{ "12345" });
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 5:02:36 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back("12345");
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 5:09:31 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back();
	v.emplace_back("여긴 인자만 인자만");
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:49:50 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라.
// a -> 10
// b -> 3
// ...
// z -> 0


//--------
int main()
//--------
{
	array<int, 26> a;
	
	for (int n : a)
		cout << n << " ";
	cout << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:53:43 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라.
// a -> 10
// b -> 3
// ...
// z -> 0


//--------
int main()
//--------
{
	array<int, 26> a{};
	ifstream in{ "메인.cpp" };

	char c;
	while (in >> c) {
		if (islower(c)) {
			a[c - 'a']++;
		}
	}
	for (int i = 0; i < a.size(); ++i) {
		cout << static_cast<char>(i + 'a') << "->" << a[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:53:56 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라.
// a -> 10
// b -> 3
// ...
// z -> 0


//--------kkkkkk
int main()
//--------
{
	array<int, 26> a{};
	ifstream in{ "메인.cpp" };

	char c;
	while (in >> c) {
		if (islower(c)) {
			a[c - 'a']++;
		}
	}
	for (int i = 0; i < a.size(); ++i) {
		cout << static_cast<char>(i + 'a') << "->" << a[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:58:51 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라
	remove(v.begin(), v.end(), 3);

	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:08:00 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라
	auto new_end = remove(v.begin(), v.end(), 3);
	v.erase(new_end, v.end());

	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:11:12 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라
	erase(v, 3);

	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:23:59 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 홀수를 제거하라
	v.erase(remove_if(v.begin(), v.end(), [](int n) {
		return n & 1;
		}), v.end());


	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:44:12 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] V에서 "2"와 "4" 사이에 "3"을 삽입하라.
	v.insert(v.begin() + 2, "3");

	for (const STRING& s : v) {
		cout << s << endl;
	}


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:45:16 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	

	vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] V에서 "2"와 "4" 사이에 "3"을 삽입하라.
	관찰 = true;
	v.insert(v.begin() + 2, "3");
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:52:35 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "2","3", "4", "5" };

	// [문제] V에서 "2"와 "4" 사이에 "3"을 삽입하라.
	관찰 = true;
	remove(v.begin(), v.end(), "3");
	관찰 = false;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:53:54 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	관찰 = true;
	v.insert(++++v.begin(), "333");
	관찰 = false;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:54:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	관찰 = true;
	v.insert(++++v.begin(), "333");
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:55:16 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	STRING temp = { "333" };
	관찰 = true;
	v.insert(++++v.begin(), temp);
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:55:57 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	관찰 = true;
	v.emplace(++++v.begin(), "333");
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:00:26 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d;

	cout << "VS에서 x64일때 deque의 크기 - " << sizeof d << endl;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:02:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d{ "1", "22", "333", "4444", "55555" };

	for (int i = 0; i < d.size(); ++i) {
		cout << &d[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:03:24 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	deque<STRING> d{ "1", "22", "333", "4444", "55555" };
	관찰 = false;

	for (int i = 0; i < d.size(); ++i) {
		cout << &d[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:06:04 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	deque<STRING> d{ "1", "22", "333", "4444"};
	관찰 = false;

	d.push_front("0");
	d.push_front("-1");

	for (const STRING& d : d) {
		cout << d << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:07:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d{ "1", "22", "333", "4444"};

	for (const STRING& s : d) {
		cout << (void*)&s << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:08:45 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d{ "1", "22", "333", "4444"};

	관찰 = true;
	for (const STRING& s : d) {
		cout << (void*)&s << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:09:48 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	deque<STRING> d{ "1", "22", "333", "4444"};

	for (const STRING& s : d) {
		cout << (void*)&s << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:29:27 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<STRING> v{ "1", "22", "333", "4444", "55555" };

	//관찰 = true;
	erase(v, "333");
	//관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:30:10 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<STRING> v{ "1", "22", "333", "4444", "55555" };

	관찰 = true;
	erase(v, "333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:31:21 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "333", "4444", "55555" };

	관찰 = true;
	erase(v, "333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:45:14 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "333", "4444", "55555" };

	관찰 = true;
	v.remove("333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 3:06:34 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	list<STRING> cont{ "1", "333", "55555", "4444", "22" };


	관찰 = false;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 3:07:36 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	list<STRING> cont{ "1", "333", "55555", "4444", "22" };

	for (const STRING& s : cont)
		cout << s << endl;
	관찰 = false;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:34:10 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v;

	cout << "최대 개수 - " << v.max_size() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:40:45 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

class Test {
	char x[1'000'000];
};

//--------
int main()
//--------
{
	{
		vector<Test> v; 
		try{
			while (true) {
				v.emplace_back();
			}
		}
		catch (...) {
			cout << "최대 원소 수  - " << v.size() << endl;
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:43:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

class Test {
	char x[1'000'000];
};

//--------
int main()
//--------
{
	{	// 최대 원소 수  - 27310
		vector<Test> v; 
		try{
			while (true) {
				v.emplace_back();
			}
		}
		catch (...) {
			cout << "최대 원소 수  - " << v.size() << endl;
		}
	}

	{	// 최대 원소 수  - 
		deque<Test> d;
		try {
			while (true) {
				d.emplace_back();
			}
		}
		catch (...) {
			cout << "최대 원소 수  - " << d.size() << endl;
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:48:06 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 모든 원소를 출력하라.
	for (int num : cont)
		cout << num << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:49:34 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 두 번째 원소부터 끝까지 출력하라.
	for (int num : cont | views::drop(1))
		cout << num << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:02:57 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 두 번째 원소부터 끝까지 출력하라.
	// list<int>::iterator beg = cont.begin();
	auto beg = cont.begin();
	++beg;
	for (auto i = beg; i != cont.end(); ++i) 
		cout << *i << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:03:54 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 두 번째 원소부터 끝까지 출력하라.
	// list<int>::iterator beg = cont.begin();
	for (auto i = ++ ++cont.begin(); i != cont.end(); ++i) 
		cout << *i << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:07:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.begin(); i != cont.end(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:08:43 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <unordered_set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	unordered_set<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.begin(); i != cont.end(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:09:28 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.begin(); i != cont.end(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:11:04 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.rbegin(); i != cont.rend(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:34:42 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> cont;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	in >> s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:39:41 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	while (in >> s) 
		단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:40:20 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	while (in >> s) 
		단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:42:58 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	in >> s;
	cout << s << endl;
	//while (in >> s) 
	//	단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:47:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	in >> s;
	cout << s << endl;
	//while (in >> s) 
	//	단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:05:22 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250508;

	list<STRING> 단어들{ istream_iterator<STRING>{in}, {} };

	// 길이가 5인 단어만 화면에 출력하라
	for (const STRING& 단어 : 단어들) {
		if (단어.size() == 5)
			cout << 단어 << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:05:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250508;

	list<STRING> 단어들{ istream_iterator<STRING>{in}, {} };

	// 길이가 5인 단어만 화면에 출력하라
	for (const STRING& 단어 : 단어들) {
		if (단어.size() == 6)
			cout << 단어 << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:06:23 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250508;

	list<STRING> 단어들{ istream_iterator<STRING>{in}, {} };

	// 길이가 5인 단어만 화면에 출력하라
	for (const STRING& 단어 : 단어들) {
		if (단어.size() == 5)
			cout << 단어 << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:25:17 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250508;

	list<STRING> 단어들{ istream_iterator<STRING>{in}, {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	copy(단어들.begin(), 단어들.end(), ostream_iterator<STRING>{cout, "\n"});
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:26:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250508;

	list<STRING> 단어들{ istream_iterator<STRING>{in}, {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	copy_if(단어들.begin(), 단어들.end(), ostream_iterator<STRING>{cout, "\n"},
		[](const STRING& 단어) {
		return 5 == 단어.size();
	});
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:29:38 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250508;

	list<STRING> 단어들{ istream_iterator<STRING>{in}, {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	copy_if(단어들.begin(), 단어들.end(), ostream_iterator<STRING>{cout, "\n"},
		[](const STRING& 단어) {
		return 5 == 단어.size();
	});
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:34:23 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<string> 목록1{ "1", "55555", "333" };
	list<string> 목록2{ "4444", "22" };

	목록1.merge(목록2);

	for (const string& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:34:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<string> 목록1{ "1", "55555", "333" };
	list<string> 목록2{ "4444", "22" };

	목록1.merge(목록2);

	for (const string& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	for (const string& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:35:34 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<string> 목록1{ "1", "55555", "333" };
	list<string> 목록2{ "4444", "22" };

	목록1.merge(목록2);

	for (const string& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	for (const string& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:37:56 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<string> 목록1{ "1", "55555", "333" };
	list<string> 목록2{ "4444", "22" };

	// 정렬 후 merge 해야한다.
	목록1.sort();
	목록2.sort();
	목록1.merge(목록2);

	for (const string& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	for (const string& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:43:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<STRING> 목록1{ "1", "55555", "333" };
	list<STRING> 목록2{ "4444", "22" };

	// 정렬 후 merge 해야한다.
	목록1.sort();
	목록2.sort();
	목록1.merge(목록2);

	for (const STRING& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	for (const STRING& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:45:24 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<STRING> 목록1{ "1", "55555", "333" };
	list<STRING> 목록2{ "4444", "22" };

	// 정렬 후 merge 해야한다.
	목록1.sort();
	목록2.sort();

	관찰 = true;
	목록1.merge(목록2);
	관찰 = false;

	for (const STRING& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	for (const STRING& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:45:48 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<STRING> 목록1{ "1", "55555", "333" };
	list<STRING> 목록2{ "4444", "22" };

	// 정렬 후 merge 해야한다.
	관찰 = true;
	목록1.sort();
	목록2.sort();

	
	목록1.merge(목록2);
	관찰 = false;

	for (const STRING& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	for (const STRING& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:56:23 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//		forward_list<T> -
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	forward_list<STRING> cont;

	cout << sizeof cont << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 4:59:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				  sort(), unique(), merge(), splice();
//		forward_list<T> -
//			It is intended that forward_list have zero space or time overhead
//			relative to a hand-written C-style singly linked list.
//			Features that woul conflict with that goal have been omitted.
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <algorithm>
#include <string>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	forward_list<STRING> cont;

	cout << sizeof cont << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 5:06:42 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <vector>
#include <deque>
#include <span>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

void f(span<int> s )
{
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << " ";
	cout << endl;
}

//--------
int main()
//--------
{
	int a[]{ 1,2,3,4,5,5,6,7 };

	// 거꾸로 출력하라.
	f(a);

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-08 오후 5:11:24 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <vector>
#include <deque>
#include <span>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

void f(span<int> s )
{
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << " ";
	cout << endl;
}

//--------
int main()
//--------
{
	int a[]{ 1,2,3,4,5,5,6,7 };

	// 거꾸로 출력하라.
	f(a);

	vector<int> v{ begin(a), end(a) };	// { &a[0], &a[7] };
	f(v);

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 1:39:14 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
//  Iterator
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	std::string s{ "2025 5 13" };

	cout << s << endl;

	for (char c : s)
		cout << c << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 1:52:29 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
//  Iterator
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	STRING s{ "2025 5 13" };

	cout << s << endl;

	// syntactic sugar
	for (char c : s)
		cout << c << " ";
	/*for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << " ";*/

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 2:10:52 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// 반복자는 포인터를 일반화한 것이다.
	ostream_iterator<char> p{ cout };
	
	*p = 'A';
	++p;
	*p = 'B';
	++p;
	*p = 'C';
	++p;
	*p = '\n';

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 2:15:13 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// 반복자는 포인터를 일반화한 것이다.
	ostream_iterator<char> p{ cout };
	
	p.operator*() = 'A';
	*p = 'B';
	*p = 'C';
	*p = '\n';

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 2:35:54 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	std::string s{ "2025 5 13" };
	
	// [문제] s의 글자를 거꾸로 출력하라

	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 2:36:50 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	std::string s{ "2025 5 13" };
	
	// [문제] s의 글자를 거꾸로 출력하라

	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i;
	cout << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 2:42:15 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	STRING s{ "2025 5 13" };
	
	// [문제] s의 글자를 거꾸로 출력하라
	for (auto i = s.rbegin(); i != s.rend(); --i)
		cout << *i;
	cout << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:02:44 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	STRING s{ "2025 5 13" };
	
	// [문제] s의 글자를 거꾸로 출력하라
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i;
	cout << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:09:32 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

void f(array<int, 2>::iterator i) 
{
	// 어떤 종류
	cout<< "array의 반복자 - " << typeid(i).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	array<int, 2> a;

	f(a.begin());

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:12:37 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	// 어떤 종류
	cout<< "array의 반복자 - " << typeid(i).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	array<int, 2> a;
	f(a.begin());

	vector<char> v;
	f(v.end());

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:13:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	// 어떤 종류
	cout<< "array의 반복자 - " << typeid(반복자).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	array<int, 2> a;
	f(a.begin());

	vector<char> v;
	f(v.end());

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:13:47 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	// 어떤 종류
	cout<< "array의 반복자 - " << typeid(반복자).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	array<int, 2> a;
	f(a.begin());

	vector<char> v;
	f(v.end());

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:14:07 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	// 어떤 종류
	cout<< "반복자의 반복자 - " << typeid(반복자).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	array<int, 2> a;
	f(a.begin());

	vector<char> v;
	f(v.end());

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:18:43 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	// 어떤 종류
	cout<< "반복자의 반복자 - " << typeid(반복자::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	array<int, 2> a;
	f(a.begin());

	vector<char> v;
	f(v.end());

	f(deque<STRING>::iterator{});

	f(list<int>{}.rbegin());

	f(forward_list<int>::const_iterator{});

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-13 오후 3:19:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	// 어떤 종류
	cout<< "반복자의 반복자 - " << typeid(반복자::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	array<int, 2> a;
	f(a.begin());

	vector<char> v;
	f(v.end());

	f(deque<STRING>::iterator{});

	f(list<int>{}.rbegin());

	f(forward_list<int>::const_iterator{});

	f(ostream_iterator<char>{cout});

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-15 오후 3:43:17 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 15일 목요일							(11주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	// 어떤 종류
	cout<< "반복자의 반복자 - " << typeid(반복자::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	// [문제] 반복자는 종류(6 category)가 있다. 
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다ㅏ.
	// 다음 코드가 문제 없이 실행되게 하자

	f(istream_iterator<char>{cin});
	f(ostream_iterator<char>{cout});
	
	f(forward_list<int>{}.begin());
	f(list<STRING>::iterator{});

	f(deque<int>::reverse_iterator{});

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-15 오후 4:14:40 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 15일 목요일							(11주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	int* p;

	f(p);

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-15 오후 4:16:32 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 15일 목요일							(11주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	// vector는 진짜 메모리가 constiguous
	// deque는 contiguous 아니다.
	// 그런데 
	
	f(vector<int>{}.begin());
	f(deque<int>{}.begin());

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-15 오후 4:27:44 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 15일 목요일							(11주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	
	// 벡터는 C++20의 concept을 이용하여 contiguous임을 판정할 수 있다.
	cout << "벡터의 반복자 - " << typeid(반복자::iterator_concept).name() << endl;
}

//--------
int main()
//--------
{
	// vector는 진짜 메모리가 constiguous
	
	f(vector<int>{}.begin());

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-15 오후 4:33:38 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 15일 목요일							(11주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <concepts>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	
	// 벡터는 C++20의 concept을 이용하여 contiguous임을 판정할 수 있다.
	cout << "벡터의 반복자 - " << typeid(반복자::iterator_concept).name() << endl;
}

//--------
int main()
//--------
{
	cout << boolalpha<< contiguous_iterator<vector<int>::iterator> << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-15 오후 4:34:25 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 15일 목요일							(11주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include <concepts>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	
	// 벡터는 C++20의 concept을 이용하여 contiguous임을 판정할 수 있다.
	cout << "벡터의 반복자 - " << typeid(반복자::iterator_concept).name() << endl;
}

//--------
int main()
//--------
{
	cout << boolalpha<< contiguous_iterator<deque<int>::iterator> << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 2:06:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	
	// 벡터는 C++20의 concept을 이용하여 contiguous임을 판정할 수 있다.
	cout << "벡터의 반복자 - " << typeid(반복자::iterator_concept).name() << endl;
}

//--------
int main()
//--------
{
	STRING s{ "2025 5 15" };

	// [문제] 문제없이 실행되게 하라.
	sort(s.begin(), s.end());

	cout << s << endl;				// "  0122555"	

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 2:08:38 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers that 
// allow a C++ program to work with different data structures in a uniform manner. 
// 
// 반복자는 클래스로 코딩해야 합니다.
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template<class 반복자>
void f( 반복자 i ) 
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
	
	// 벡터는 C++20의 concept을 이용하여 contiguous임을 판정할 수 있다.
	cout << "벡터의 반복자 - " << typeid(반복자::iterator_concept).name() << endl;
}

//--------
int main()
//--------
{
	STRING s{ "2025 5 20" };

	sort(s.begin(), s.end(), [](char a, char b) {
		return a > b;
		});

	cout << s << endl;	

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 2:37:16 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// 반복자와 알고리즘
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	STRING s{ "lazy fox jumps over the brown dog" };

	sort(s.begin(), s.end());

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 2:38:44 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// 반복자와 알고리즘
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	STRING s{ "the quick brown fox jumps over the lazy dog" };

	sort(s.begin(), s.end());

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 2:39:55 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// 반복자와 알고리즘
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	STRING s{ "the quick brown fox jumps over the lazy dog" };

	sort(s.begin(), s.end());
	unique(s.begin(), s.end());

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 3:00:39 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// 반복자와 알고리즘
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template <class 반복자,class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v) {
	while (b != e) {
		if (*b == v) {
			return b;
		}
		++b;
	}
	return b;
}

//--------
int main()
//--------
{
	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] v에서 처음 나오는 짝수가 무엇인지 출력하라.
	auto p = find_if(v.begin(), v.end(), [](int n) {
		return not(n & 1);
		});

	if (p != v.end())
		cout << "처음 만난 짝수는 --- " << *p << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 3:06:30 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// 반복자와 알고리즘
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template <class 반복자,class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (*b == v) {
			return b;
		}
		++b;
	}
	return b;
}

template <class 반복자, class Pred>
반복자 my_find_if(반복자 시작, 반복자 끝, Pred f) 
{
	for (; 시작 != 끝; ++시작) {
		if (f(*시작))
			return 시작;
	}
	return 끝;
}

//--------
int main()
//--------
{
	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] v에서 처음 나오는 짝수가 무엇인지 출력하라.
	auto p = my_find_if(v.begin(), v.end(), [](int n) {
		return not(n & 1);
		});

	if (p != v.end())
		cout << "처음 만난 짝수는 --- " << *p << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 3:08:07 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// 반복자와 알고리즘
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template <class 반복자,class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (*b == v) {
			return b;
		}
		++b;
	}
	return b;
}

template <class 반복자, class Pred>
반복자 my_find_if(반복자 시작, 반복자 끝, Pred f) 
{
	for (; 시작 != 끝; ++시작) {
		if (f(*시작))
			return 시작;
	}
	return 끝;
}

//--------
int main()
//--------
{
	STRING s{ "반복자를 사용한 알고리즘을 연습 중" };
	vector<char> v;

	copy(s.begin(), s.end(), ostream_iterator<char>{cout});

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-20 오후 3:17:02 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 20일 화요일							(11주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// 반복자와 알고리즘
//---------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

template <class 반복자,class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (*b == v) {
			return b;
		}
		++b;
	}
	return b;
}

template <class 반복자, class Pred>
반복자 my_find_if(반복자 시작, 반복자 끝, Pred f) 
{
	for (; 시작 != 끝; ++시작) {
		if (f(*시작))
			return 시작;
	}
	return 끝;
}

template <class 반복자, class 목적지반복자>
void my_copy(반복자 b, 반복자 e, 목적지반복자 d) 
{
	while (b != e) {
		*d = *b;
		++b;
		++d;
	}
}

//--------
int main()
//--------
{
	STRING s{ "반복자를 사용한 알고리즘을 연습 중" };
	vector<char> v{ '1' };

	my_copy(s.begin(), s.end(), back_inserter(v));
	
	for (char c : v)
		cout << c;
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:11:28 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> s{ 1,3,5,7,9,2,4,6,8,10 };
	
	for (int n : s)
		cout << n << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:12:00 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> s{ 1,3,5,7,9,2,4,6,8,10,1,1,1,1,1,1 };
	
	for (int n : s)
		cout << n << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:21:22 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> s{ 1,3,5,7,9,2,4,6,8,10,1,1,1,1,1,1 };
	

	// 거꾸로 출력하라
	for (auto b = s.cbegin(); b != s.cend(); ++b )
		cout << *b << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:21:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> s{ 1,3,5,7,9,2,4,6,8,10,1,1,1,1,1,1 };
	

	// 거꾸로 출력하라
	for (auto b = s.rbegin(); b != s.rend(); ++b )
		cout << *b << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:23:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> s{ 1,3,5,7,9,2,4,6,8,10,1,1,1,1,1,1 };
	

	// 거꾸로 출력하라
	for (int n : s | views::reverse)
		cout << n << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:24:24 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> s{ 1,3,5,7,9,2,4,6,8,10,1,1,1,1,1,1 };
	

	// 거꾸로 출력하라
	for (int n : s | views::reverse | views::reverse)
		cout << n << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:31:45 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] 키보드의 입력을 s에 저장하라.
	// s의 모든 원소를 화면에 출력하라.

	set<STRING> s{ istream_iterator<STRING>{cin}, {} };

	for (const STRING& str : s)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:45:56 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] 키보드의 입력을 s에 저장하라.
	// s의 모든 원소를 화면에 출력하라.

	set<STRING> s{ istream_iterator<STRING>{cin}, {} };

	for (const STRING& str : s)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:46:44 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] 키보드의 입력을 s에 저장하라.
	// s의 모든 원소를 화면에 출력하라.

	set<STRING> s{ istream_iterator<STRING>{cin}, {} };

	for (const STRING& str : s)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:48:49 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// less를 사용하여 바이트 수 기준으로 정렬되게 하자
	set<STRING> s{ "333", "22", "1", "4444", "55555"};

	for (const STRING& str : s)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:49:08 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// less를 사용하여 바이트 수 기준으로 정렬되게 하자
	set<STRING> s{ "333", "22", "11111", "44", "5"};

	for (const STRING& str : s)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:55:30 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

class 길이 {
public:
	bool operator()(const STRING& a, const STRING& b) const
	{
		return a.size() < b.size();
	}
};

//--------
int main()
//--------
{
	// [문제] s를 기본정렬기준인 less를 사용하여 바이트 수 기준으로 정렬되게 하자
	set<STRING, 길이> s{ "333", "2222", "11111", "44", "5"};

	for (const STRING& str : s)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-22 오후 4:57:18 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 22일 목요일							(12주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

class 길이 {
public:
	// const 일관서을 지켜서 코딩한다.
	bool operator()(const STRING& a, const STRING& b) const
	{
		return a.size() < b.size();
	}
};

//--------
int main()
//--------
{
	// [문제] s를 기본정렬기준인 less를 사용하여 바이트 수 기준으로 정렬되게 하자
	set<STRING> s{ "333", "2222", "11111", "44", "5"};

	for (const STRING& str : s)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-29 오후 3:38:52 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(12주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	for (const STRING& s : ms)
		cout << s << " ";
	cout << endl;

	// 동일 단어가 몇 개 있는지 알려주자
	while (true) {
		cout << "찾을 단어? ";
		STRING 단어;
		cin >> 단어;

		cout << ms.count(단어) << "개 있습니다." << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 3:45:07 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(12주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	for (const STRING& s : ms)
		cout << s << " ";
	cout << endl;

	// 동일 단어가 몇 개 있는지 알려주자
	while (true) {
		cout << "찾을 단어? ";
		STRING 단어;
		cin >> 단어;

		// cout << ms.count(단어) << "개 있습니다." << endl;

		// 문제를 변형하여 입력한 단어가 추가되어도 멀티셋의 정렬상태가 바뀌지 않을
		// 위치를 알고 싶다.
		ms.equal_range(단어);
	}
} 

======================================
저장한 시간: 2025-05-29 오후 3:51:06 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(12주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	for (const STRING& s : ms)
		cout << s << " ";
	cout << endl;

	// 동일 단어가 몇 개 있는지 알려주자
	while (true) {
		cout << "찾을 단어? ";
		STRING 단어;
		cin >> 단어;

		// cout << ms.count(단어) << "개 있습니다." << endl;

		// 문제를 변형하여 입력한 단어가 추가되어도 멀티셋의 정렬상태가 바뀌지 않을
		// 위치를 알고 싶다.
		// 이 방식으로 개수를 셀 수도 있다.
		pair<multiset<STRING>::const_iterator, multiset<STRING>::const_iterator> 동등한위치 
			= ms.equal_range(단어);

		if (동등한위치.first == 동등한위치.second) {
			cout << "찾는 단어는 없습니다" << endl;
		}
		else {
			cout << distance(동등한위치.first, 동등한위치.second) << endl;
		}
	}
} 

======================================
저장한 시간: 2025-05-29 오후 3:55:25 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(12주 2일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <set>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	for (const STRING& s : ms)
		cout << s << " ";
	cout << endl;

	// 동일 단어가 몇 개 있는지 알려주자
	while (true) {
		cout << "찾을 단어? ";
		STRING 단어;
		cin >> 단어;

		// cout << ms.count(단어) << "개 있습니다." << endl;

		// 문제를 변형하여 입력한 단어가 추가되어도 멀티셋의 정렬상태가 바뀌지 않을
		// 위치를 알고 싶다.
		// 이 방식으로 개수를 셀 수도 있다.
		auto [하한, 상한] = ms.equal_range(단어);	// structured binding

		if (하한 == 상한) {
			cout << "찾는 단어는 없습니다" << endl;
		}
		else {
			cout << distance(하한, 상한) << endl;
		}
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:01:43 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 출력하라.
//		a - 1030
//		b - 300
//		
//		z - 30

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	array<int, 26> alpha{}; // 'a' ~ 'z'

	for (const auto& word : ms) {
		for (char ch : word) {
			if (isalpha(ch)) {
				ch = tolower(ch);  // 대소문자 구분 없이 처리
				alpha[ch - 'a']++;
			}
		}
	}

	for (int i = 0; i < 26; ++i) {
		cout << static_cast<char>('a' + i) << " - " << alpha[i] << '\n';
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:12:16 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 출력하라.
//		대문자는 모두 소문자로 바꿔라
//		a - 1030
//		b - 300
//		
//		z - 30

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	array<size_t, 26> a{};

	for (const auto& word : ms) {
		for (char c : word) {
			a[tolower(c) - 'a']++;
		}
	}

	for (size_t i = 0; i < a.size(); ++i) {
		cout << 'a' + i << " - " << a[i] << '\n';
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:12:42 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 출력하라.
//		대문자는 모두 소문자로 바꿔라
//		a - 1030
//		b - 300
//		
//		z - 30

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	array<size_t, 26> a{};

	for (const auto& word : ms) {
		for (char c : word) {
			a[tolower(c) - 'a']++;
		}
	}

	for (size_t i = 0; i < a.size(); ++i) {
		cout << 'a' + i << " - " << a[i] << '\n';
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:12:56 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 출력하라.
//		대문자는 모두 소문자로 바꿔라
//		a - 1030
//		b - 300
//		
//		z - 30

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	array<size_t, 26> a{};

	for (const auto& word : ms) {
		for (char c : word) {
			a[tolower(c) - 'a']++;
		}
	}

	for (size_t i = 0; i < a.size(); ++i) {
		cout << char('a' + i) << " - " << a[i] << '\n';
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:14:31 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 출력하라.
//		대문자는 모두 소문자로 바꿔라
//		a - 1030
//		b - 300
//		
//		z - 30

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	array<size_t, 26> a{};

	for (const auto& word : ms) {
		for (char c : word) {
			a[tolower(c) - 'a']++;
		}
	}

	for (size_t i = 0; i < a.size(); ++i) {
		cout << static_cast<char>(i + 'a') << " - " << a[i] << '\n';
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:29:14 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 출력하라.
//		대문자는 모두 소문자로 바꿔라
//		a - 1030
//		b - 300
//		
//		z - 30

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (c = tolower(c)) {
				alphaNum[c]++;
			}
		}
	}

	for (auto [소문자, 개수] : alphaNum) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:31:33 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 출력하라.
//		대문자는 모두 소문자로 바꿔라
//		a - 1030
//		b - 300
//		
//		z - 30

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (isalpha(c)) {
				alphaNum[tolower(c)]++;
			}
		}
	}

	for (auto [소문자, 개수] : alphaNum) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:38:27 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 많이 사용된 순서대로 출력하라.


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (isalpha(c)) {
				alphaNum[tolower(c)]++;
			}
		}
	}

	// map → vector로 복사
	vector<pair<char, size_t>> alphaVec(alphaNum.begin(), alphaNum.end());

	// 빈도 기준으로 내림차순 정렬
	sort(alphaVec.begin(), alphaVec.end(),
		[](const pair<char, size_t>& a, const pair<char, size_t>& b) {
		return a.second > b.second;  // 값이 큰 게 먼저 오게
	});

	for (auto [소문자, 개수] : alphaNum) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:38:45 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 많이 사용된 순서대로 출력하라.


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (isalpha(c)) {
				alphaNum[tolower(c)]++;
			}
		}
	}

	// map → vector로 복사
	vector<pair<char, size_t>> alphaVec(alphaNum.begin(), alphaNum.end());

	// 빈도 기준으로 내림차순 정렬
	sort(alphaVec.begin(), alphaVec.end(),
		[](const pair<char, size_t>& a, const pair<char, size_t>& b) {
		return a.second > b.second;  // 값이 큰 게 먼저 오게
	});

	for (auto [소문자, 개수] : alphaNum) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:39:03 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 많이 사용된 순서대로 출력하라.


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (isalpha(c)) {
				alphaNum[tolower(c)]++;
			}
		}
	}

	// map → vector로 복사
	vector<pair<char, size_t>> alphaVec(alphaNum.begin(), alphaNum.end());

	// 빈도 기준으로 내림차순 정렬
	sort(alphaVec.begin(), alphaVec.end(),
		[](const pair<char, size_t>& a, const pair<char, size_t>& b) {
		return a.second > b.second;  // 값이 큰 게 먼저 오게
	});

	for (auto [소문자, 개수] : alphaVec) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:53:20 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 많이 사용된 순서대로 출력하라.


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (isalpha(c)) {
				alphaNum[tolower(c)]++;
			}
		}
	}

	map<size_t, char> numAlpha;
	for (auto [소문자, 개수] : alphaNum) {
		numAlpha[개수] = 소문자;
	}

	for (auto [개수, 소문자] : numAlpha) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:54:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 많이 사용된 순서대로 출력하라.


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (isalpha(c)) {
				alphaNum[tolower(c)]++;
			}
		}
	}

	map<size_t, char, greater<size_t>> numAlpha;
	for (auto [소문자, 개수] : alphaNum) {
		numAlpha[개수] = 소문자;
	}

	for (auto [개수, 소문자] : numAlpha) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 4:55:33 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <array>
#include <ranges>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 이 소설에 사용된 알파벳의 개수를 다음과 같이 많이 사용된 순서대로 출력하라.


//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	multiset<STRING> ms{ istream_iterator<STRING>{in}, {} };
	cout << "읽은 단어 수 - " << ms.size() << endl;		// 26626

	// [3] 알파벳 사용 빈도 세기
	map<char, size_t> alphaNum;		// 연관 배열

	for (const STRING& 단어 : ms) {
		for (char c : 단어) {
			if (isalpha(c)) {
				alphaNum[tolower(c)]++;
			}
		}
	}

	map<size_t, char, greater<size_t>> numAlpha;
	for (auto [소문자, 개수] : alphaNum) {
		numAlpha[개수] = 소문자;
	}

	for (auto [개수, 소문자] : numAlpha | views::reverse) {
		cout << 소문자 << " - " << 개수 << endl;
	}
} 

======================================
저장한 시간: 2025-05-29 오후 5:10:38 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 5월 29일 목요일							(13주 1일)
// 6월 19일 목요일 15주 2일 - 기말시험
//---------------------------------------------------------------------------
// Associative Container - key와 연관된 value를 항상 정렬상태로 유지한다.
//						   정렬은 key값을 기준으로 한다.
//	set	/ mutiset	- key == value
//  map	/ multimap	- pair<key, value>
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <format>
#include <print>
#include <map>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// 강의자료 "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] 여기에 있는 모든 단어를 multiset<STRING>에 저장하라.
// [2] 모두 몇 단어인지 화면에 출력하라.	- 26626
// [3] 단어와 사용횟수를 화면에 출력하라.

//--------
int main()
//--------
{
	save("메인.cpp");

	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in) {
		cout << "파일?" << endl;
		return 20250527;
	}

	map<STRING, size_t> wordNum;

	STRING 단어;
	while (in >> 단어)
		wordNum[단어]++;
	
	for (auto [단어, 개수] : wordNum)
		cout << 단어 << " - " << 개수 << endl;
		//println("{:20} - {:}", 단어[0], 개수);
} 