//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::ofstream out{ "2025 1 STL 화56목78 강의저장.txt", std::ios::app };

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;
}//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, v.begin());
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator{ out });
}                                                   
//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();		// time_point를 얻는다, epoch
	std::cout << now << std::endl;


	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}
//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();		// time_point를 얻는다, epoch
	using namespace std::chrono_literals;
	std::cout << now + 9h << std::endl;


	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-06 오후 5:03:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			// time_point를 얻는다, epoch
	auto utc = std::chrono::system_clock::to_time_t(now);	// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "======================================" << '\n';
	out << '\n';

	out.imbue(old);		// 원래 locale로 복귀

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-06 오후 5:04:17 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일								(1주 2일)
//---------------------------------------------------------------------------
// 컴파일 환경 확인 / 한학기 강의를 저장할 save 만들기
//---------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++lastest, SDL 검사 - 아니요
// --------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			// time_point를 얻는다, epoch
	auto utc = std::chrono::system_clock::to_time_t(now);	// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "======================================" << '\n';
	out << '\n';

	out.imbue(old);		// 원래 locale로 복귀

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-11 오후 1:49:35 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] save 기능을 파일로 분리하라

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 1:51:25 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] save 기능을 파일로 분리하라

//--------
int main()
//--------
{
	std::cout << "2025 STL" << std::endl;

	save("메인.cpp");
	save("save.h");
	save("save.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 1:51:25 화요일
======================================

//-----------------------------------------------------------------
// save.h											2025년 3월 11일
//-----------------------------------------------------------------


#pragma once
void save(std::string_view);

======================================
저장한 시간: 2025-03-11 오후 1:51:25 화요일
======================================

//-----------------------------------------------------------------
// save.cpp											2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수 입니다.
//-----------------------------------------------------------------


#include <string>
#include <fstream>
#include <iostream>
#include <filesystem>
#include <chrono>

//-----------------------------
void save(std::string_view fileName)
//-----------------------------
{
	// fileName을 읽기 모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 쓰기 모드로 저장할 파일을 연다.
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app };

	// 저장했다고 화면에 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "에 " << fileName << "를 덧붙였습니다. - "
		<< size << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			// time_point를 얻는다, epoch
	auto utc = std::chrono::system_clock::to_time_t(now);	// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "======================================" << '\n';
	out << '\n';

	out.imbue(old);		// 원래 locale로 복귀

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

======================================
저장한 시간: 2025-03-11 오후 1:57:22 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

void change(int& a, int& b);

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("메인.cpp");
}

void change(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

======================================
저장한 시간: 2025-03-11 오후 2:03:05 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

void change(int&, int&);

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("메인.cpp");
}

void change(int& a, int& b) 
{
	int temp{ a };
	a = b;
	b = temp;
}

======================================
저장한 시간: 2025-03-11 오후 2:13:14 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

template <typename T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

template <typename T>
class Dog {
private:
	T num;
public:
	Dog(T num) : num(num){}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
};

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:28:29 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] main을 수정하지 말고 의도대로 실행되게 하라.

class Dog {
public:
	Dog(){}
	Dog(int num) : num(num) {}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
private:
	int num{};
};


void change(int& , int& );
void change(Dog&, Dog&);

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

void change(int& a, int& b) 
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) 
{
	Dog temp{ a };
	a = b;		
	b = temp;
}	

======================================
저장한 시간: 2025-03-11 오후 2:36:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] c++ 언어에서 change 함수는 몇 번이나 overlading 해야할까?
// --> c++ 언어의 자료형은 몇 개인가? --> 무한하다(만들수 있기 때문)

class Dog {
public:
	Dog(){}
	Dog(int num) : num(num) {}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
private:
	int num{};
};

template <class T>
void change(T&, T&);

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

template <class T>
void change(T& a, T& b) 
{
	T temp{ a };
	a = b;
	b = temp;
}

======================================
저장한 시간: 2025-03-11 오후 2:54:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// template 복습
//---------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;							// 우리는 이렇게 하면 안된다

// [문제] c++ 언어에서 change 함수는 몇 번이나 overlading 해야할까?
// --> c++ 언어의 자료형은 몇 개인가? --> 무한하다(만들수 있기 때문)

class Dog {
public:
	Dog(){}
	Dog(int num) : num(num) {}

	// 출력 연산자 오버로딩 추가
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
private:
	int num{};
};

template <class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

//--------
int main()
//--------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		// 1. change(DOg, Dog);	있니?
		// 2. change(Dog&, Dog&); 동시에 존재시 (모호하다.)
		// 3. 컴파일러가 template을 이용하여 코드 생성
		cout << a << ", " << b << endl;		// 의도 - 2, 1이 출력되어야 한다.
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:58:16 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<int> dis(0, 99);

//--------
int main()
//--------
{
	for (int i{}; i < 100; ++i) {
		cout << dis(gen) << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:58:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<int> dis(0, 99);

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i) {
		cout << dis(gen) << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 2:59:07 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<int> dis(0, 99);

//--------
int main()
//--------
{
	int rand_num[1000];

	for (int i{}; i < 1000; ++i) {
		rand_num[i] = dis(gen);
		cout << rand_num[i] << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-11 오후 3:07:58 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9999999 };

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:36:32 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:37:50 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre{ random_device{}() };
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:38:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre{ random_device{}() };
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	for (int i{}; i < 1000; ++i)
		print("{:8}", uid(dre));
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:42:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre{ random_device{}() };
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	// 내가 해본거
	int rand_num[1000]{};

	int max{};

	for (int i{}; i < 1000; ++i) {
		rand_num[i] = uid(dre);
		if (max < rand_num[i]) {
			max = rand_num[i];
		}
	}
	cout << max << endl;

	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 3:52:16 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	// T[N]
	int arr[1'000];

	for (int i = 0; i < 1000; ++i)
		arr[i] = uid(dre);

	int maxValue{numeric_limits<int>::min()};

	for (int i = 0; i < 1000; ++i) {
		if (maxValue < arr[i])
			maxValue = arr[i];
	}

	cout << "최댓값 - " << maxValue << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:11:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라

//--------
int main()
//--------
{
	array<int, 1'000> arr;			// T[N] --> array<T,N>

	for (int& num : arr)
		num = uid(dre);

	cout << "최댓값 - " << *max_element(arr.begin(), arr.end()) << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:25:15 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	print("{:80}", 20250311);

	/*for (int i = 0; i < 1'000; ++i)
		print("{:8}", uid(dre));*/

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:25:40 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	print("{:<80}", 20250311);

	/*for (int i = 0; i < 1'000; ++i)
		print("{:8}", uid(dre));*/

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:36:44 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	ofstream out{ "int 1000개.txt" };		// RAII
	

	for (int i = 0; i < 1'000; ++i)
		print(out, "{:8}", uid(dre));

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:39:48 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// 랜덤 int 1000개를 생성하여 화면에 출력하라

default_random_engine dre;
std::uniform_int_distribution uid{ 0, 999'9999 };

// [문제] 랜덤 int값 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int 값을 가져올 수 있어야 한다.

//--------
int main()
//--------
{
	ofstream out{ "int 1000개.txt" };		// RAII
	
	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		print(out, "{:8}", uid(dre));
		if (not(++cnt % 10))
			out << endl;
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:44:55 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	// 내가 쓴거
	ifstream in{ "int 1000개.txt" };

	string str;
	while (in >> str) {
		cout << str;
	}
	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:45:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <print>		// C++23
#include <fstream>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	// 내가 쓴거
	ifstream in{ "int 1000개.txt" };

	string str;
	while (in >> str) {
		cout << str << endl;
	}
	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:52:22 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue{ numeric_limits<int>::min() };
	size_t cnt{ };

	while (in >> num) {
		++cnt;
		if (maxValue < num)
			maxValue = num;
	}
	cout << "읽은 개수 - " << cnt << endl;
	cout << "최댓값 - " << maxValue << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 4:58:55 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.

//--------
int main()
//--------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout << "최댓값 - " << *max_element(istream_iterator<int>{in}, {}) << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 5:05:25 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다. 
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라. (5분)

//--------
int main()
//--------
{
	// 내가 쓴거
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array <int, 1000> arr;

	for (int& data : arr) {
		int temp;
		in >> temp;
		data = temp;
	}

	print(":8", arr);

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-13 오후 5:10:35 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(2주 2일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다. 
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라. (5분)

//--------
int main()
//--------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array <int, 1000> a;
	int num;
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		a[i] = num;
	}

	for (int num : a) {
		print("{:8}", num);
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:34:10 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 랜덤 데이터를 생성하기
//							/  파일 텍스트로 기록하기
//---------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;							

// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다. 
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라. (5분)

//--------
int main()
//--------
{
	random_device rd{};
	cout << "이 값은 추적 불가능" << endl;

	for (int i = 0; i < 100; ++i)
		cout << rd() << '\n';

	/*ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array <int, 1000> a;
	int num;
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		a[i] = num;
	}

	for (int num : a) {
		print("{:8}", num);
	}*/

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:45:52 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------
#include <iostream>
#include <bitset>
#include "save.h"
using namespace std;			

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//--------
int main()
//--------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32> binary = num;

	cout << " 2진수 -  " << binary << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:47:27 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------
#include <iostream>
#include <bitset>
#include "save.h"
using namespace std;

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//--------
int main()
//--------
{
	int num{ 0x01'02'03'04 };

	bitset<32> binary = num;

	cout << " 2진수 -  " << binary << endl;
	cout << "10진수 - " << num << endl;
	cout << "16진수 - " << hex << num << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:56:04 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:56:41 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a{};

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:57:24 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	a.fill(333);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:58:51 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	int i{};
	for (int num : a)
		num = ++i;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 1:59:25 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	int i{};
	for (int& num : a)
		num = ++i;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:01:03 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 1);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:01:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include "save.h"
using namespace std;

// [문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다. 
// -> 저수준 입출력 함수를 사용한다.


//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 123);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:13:39 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 1);

	// [문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:17:43 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array <int, 1000> a;
	
	iota(a.begin(), a.end(), 1);

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;

	// [문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로", ios::binary };
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:21:03 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array <int, 1000> a;
	a.fill(0x0a0a0a0a);

	// [문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로"};
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:36:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// 파일에 "int 10만개를 바이너리 모드 write함수로 기록" 에 10만개의 랜덤 int 값을 기록하자
// 이 int값은 메모리 크기 그대로 기록한다.
// 파일은 binary mode로 열자.

default_random_engine dre;

//--------
int main()
//--------
{
	ofstream out{ "int 10만개를 바이너리 모드 write함수로 기록", ios::binary };
	
	uniform_int_distribution uid{ numeric_limits<int>::min(), numeric_limits<int>::max() };

	for (int i = 0; i < 10'0000; ++i) {
		int num = uid(dre);
		out.write((char*)&num, sizeof(int));
	}

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:59:01 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리 모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용했어)
// int값 10만개를 읽어서 메모리에 저장하라.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라
// 화면에 출력된 값도 답지에 적어라.


//--------
int main()
//--------
{
	ifstream in{ "int 10만개를 바이너리 모드 write함수로 기록", ios::binary };
	if (not in)
		return 20250318;

	array<int, 10'0000> a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 2:59:44 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리 모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용했어)
// int값 10만개를 읽어서 메모리에 저장하라.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라
// 화면에 출력된 값도 답지에 적어라.


//--------
int main()
//--------
{
	ifstream in{ "int 10만개를 바이너리 모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000> a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// -2147431498

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 3:02:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 11일 화요일								(3주 1일)
//---------------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - binary i/o
//					 -> 파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리 모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용했어)
// int값 10만개를 읽어서 메모리에 저장하라.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라
// 화면에 출력된 값도 답지에 적어라.


//--------
int main()
//--------
{
	ifstream in{ "int 10만개를 바이너리 모드 write함수로 기록", ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// -2147431498

	save("메인.cpp");
}

======================================
저장한 시간: 2025-03-27 오후 3:53:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬


	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 3:55:13 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬


	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(1000)
					 | views::take(1)
		)
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:17:01 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int, 1'000'0000>::value_type), 오름차순);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:17:52 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int, 1'000'0000>::value_type), 오름차순);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:20:55 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

int 내림차순(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// qsort로 내림차순(descending order) 정렬
	qsort(a.data(), a.size(), sizeof(array<int, 1'000'0000>::value_type), 내림차순);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:32:45 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

// 바꿔야 하면 1
// 이미 정렬상태이면 -1
// 둘이 정렬기준상 동일한 값이면 0
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;	// c언어 스타일의 케스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)(p);*/
}

int 내림차순(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	int(*정렬기준)(const void*, const void*) = (int(*)(const void*, const void*))오름차순;

	//정렬기준 = 내림차순;
	qsort(a.data(), a.size(), sizeof(int), 정렬기준);

	// 앞에서 부터 1000개를 화면 출력
	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:46:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬 
	sort(a.begin(), a.end());

	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:54:40 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬 
	sort(a.begin(), a.end(), 오름차순);		// 디폴트 정렬 operator <

	for (int num : a | views::take(3000) )
		print("{:8}", num);
	cout << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 4:57:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					// 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;

	for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 5:01:02 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid(dre);

	// 정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					// 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;
	cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	/*for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;*/

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-03-27 오후 5:04:35 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일								(4주 2일)
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>	
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
using namespace std;

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
// c++언어의 sort를 사용하여 오름차순으로 정렬하라.
// 정렬한 결과를 앞에서부터 1000개만 화면에 출력한라

array<int, 10000000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0, 999'9999 };

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
		sort(a.begin(), a.end(), 오름차순);					// 디폴트 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		// 정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	// 스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b){
				return a > b;
			});					// 디폴트 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		// 스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}


	/*for (int num : a | views::take(1000) )
		print("{:8}", num);
	cout << endl;*/

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:37:35 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	// 람다는 도대체 무엇인가?

	cout << "람다의 정체 - " << typeid([ ]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}).name() << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:39:02 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	// 람다는 도대체 무엇인가?

	cout << "람다 1의 정체 - " << typeid([ ]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}).name() << endl;

	cout << "람다 2의 정체 - " << typeid([ ]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}).name() << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:50:18 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {
		cout << "나를 왜 불렀죠?" << endl;
	}
};
//--------
int main()
//--------
{
	Dog dog;

	dog();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:51:37 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {
		cout << "나를 왜 불렀죠?" << endl;
	}
};
//--------
int main()
//--------
{
	Dog dog;

	cout << typeid(dog).name() << endl;

	dog.operator()();		// dog();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:51:59 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	class Dog {
	public:
		void operator()() {
			cout << "나를 왜 불렀죠?" << endl;
		}
	};

	Dog dog;

	cout << typeid(dog).name() << endl;

	dog.operator()();		// dog();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:59:30 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	class Dog{
	public:
		bool operator()(const int a, const int b) {
			return a > b;
		}
	};

	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num;
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 1:59:54 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	// 내가 쓴거
	class Dog{
	public:
		bool operator()(const int a, const int b) {
			return a > b;
		}
	};

	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num;
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:09:58 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	class Dog {
	public:
		bool operator()(int a, int b) const {
			return a > b;
		}
	};
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num;
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:10:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	class Dog {
	public:
		bool operator()(int a, int b) const {
			return a > b;
		}
	};
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num << " ";
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:13:53 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.

	auto Dog = [](int a, int b) ->bool { return a > b; };

	sort(a.begin(), a.end(), Dog);

	for (int num : a)
		cout << num << " ";
	cout << endl;		// 10 9 8 7 6 5 4 3 2 1
	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:27:14 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사 - 4월 24일(8주 2일) 목요일
//---------------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//---------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

//--------
int main()
//--------
{
	auto p = [](int a, int b) {return a > b; };
	cout << boolalpha << p(3, 4) << endl;

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:39:08 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a', 'z' };
uniform_int_distribution uidNameLen{ 3, 30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//--------
int main()
//--------
{
	array<Dog, 10> dogs;

	for (const Dog& dog : dogs)
		dog.show();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:39:40 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a', 'z' };
uniform_int_distribution uidNameLen{ 3, 30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		cout << "설마 생성자가?" << endl;
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//--------
int main()
//--------
{
	array<Dog, 10> dogs;

	for (const Dog& dog : dogs)
		dog.show();

	(*save)("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 2:45:33 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a', 'z' };
uniform_int_distribution uidNameLen{ 3, 30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 
// ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog)	{
//		return os << dog.id << " " << dog.name << " ";
// }


//--------
int main()
//--------
{
	ofstream out("Dog 십만마리");

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 3:06:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name;
	}
private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& d) {
		return in >> d.name >> d.id;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		in >> dog;
		dogs[i] = dog;
	}

	for (int i = 0; i < 10; ++i) {
		dogs[i].show();
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 3:07:02 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name << endl;
	}
private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& d) {
		return in >> d.name >> d.id;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	for (int i = 0; i < 10; ++i) {
		dogs[i].show();
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-01 오후 3:09:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 목요일								(5주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name << endl;
	}
private:
	string name;
	int id;

	friend  ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& dog) {
		return in >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	for (int i = 0; i < 10; ++i) {
		dogs[i].show();
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:39:26 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		cout << "id" << id << "이름" << name << endl;
	}
private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& in, Dog& dog) {
		return in >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	int num;
	string name;
	int cnt{};
	while (in >> num >> name) {
		println("[{:7}] --- {:12} {}", ++cnt, num, name);
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:46:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	//int num;
	//string name;
	//int cnt{};
	//while (in >> num >> name) {
	//	println("[{:7}] --- {:12} {}", ++cnt, num, name);
	//}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 : ";
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:56:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
	}
	size_t getNameLen() const {
		return name.length();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog dog1, const Dog dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:57:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}
	size_t getNameLen() const {
		return name.length();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog dog1, const Dog dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::take(1000))
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 3:59:32 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}
	size_t getNameLen() const {
		return name.length();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog dog1, const Dog dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::reverse)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 4:06:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}

	bool operator<(const Dog& other) const {
		return name.size() < other.name.size();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end());

	for (const Dog& dog : dogs | views::reverse)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 4:07:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// Callable
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"
using namespace std;

class Dog {
public:
	void show() const {
		print("[{:12}] - {}", id, name);
		cout << endl;
	}

	bool operator<(const Dog& other) const {
		return name.size() < other.name.size();
	}

private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

// [설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다. 
//		ofstream out("Dog 십만마리");
// 
// Dog 객체는 다음 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 열 수 없습니다 " << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보" << endl;;
	dogs.back().show();

	// 마지막 [ 100000] ---   1970393199 etpyzzulctbtq
	// [1970393199] - etpyzzulctbtq

	cout << "Dog name 길이기준 오름차순(ascending order)으로 정렬합니다. " << endl;
	sort(dogs.begin(), dogs.end());

	for (const Dog& dog : dogs | views::reverse)
		dog.show();

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 4:38:08 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class STRING {

};

//--------
int main()
//--------
{
	string s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-03 오후 5:10:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 목요일								(5주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	   (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
using namespace std;

class STRING {
public:
	STRING(const char* s) : len{ strlen(s) } {			// [] -> *로 collapsing
		p.reset();
		p = make_unique<char[]>(len);
		memcpy(p.get(), s, len);		// DMA
	}
	
	size_t size() const {
		return len;
	}

private:
	size_t len{};
	unique_ptr<char[]> p{};

	friend ostream& operator<<(ostream& os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 1:38:24 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;



//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:14:00 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수
	cout << s << endl;

	STRING t;
	t = s;

	STRING u = s;

	cout << t << endl;
	cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:14:49 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수
	cout << s << endl;

	STRING t;
	t = s;

	STRING u = s;

	cout << t << endl;
	cout << u << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:37:26 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:38:50 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:40:10 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:49:56 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	STRING t;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:51:09 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//--------
int main()
//--------
{
	STRING t = s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:53:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//--------
int main()
//--------
{
	cout << "메인시작" << endl;

	STRING t = s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 2:57:18 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//--------
int main()
//--------
{
	관찰 = false;

	cout << "메인시작" << endl;

	STRING t = s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:05:22 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };

	// 길이기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});

	for (const STRING& str : a) {
		cout << str << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:06:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };

	// 길이기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});

	관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:06:50 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };

	// 길이기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});

	관찰 = true;
	for (auto str : a) {
		cout << str << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:08:11 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	관찰 = false;

	array<STRING, 5> a{ "1", "333", "222","55555","4444" };


	// 길이기준 오름차순 정렬하고 출력하라

	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});
	관찰 = false;
	
	for (const auto& str : a) {
		cout << str << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-08 오후 3:12:09 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	4월 8일 화요일								(6주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 과제	  (30) - 4월 10일 설명
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// 다음시잔 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << s << endl;
	cout << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 3:52:29 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	// 다음시잔 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 3:53:07 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	// 다음시잔 STRING도 이렇게 동작하게 하자
	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 3:53:37 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;

	// 다음시잔 STRING도 이렇게 동작하게 하자
	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:24:42 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);

// 	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:41:08 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);

 	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:43:27 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬

	// 출력
	for (auto str : a)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:44:19 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬

	// 출력
	관찰 = true;
	for (auto str : a)
		cout << str << endl;
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 4:44:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬

	// 출력
	관찰 = true;
	for (const auto& str : a)
		cout << str << endl;
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 5:01:00 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬
	sort(a.begin(), a.end(), [] (const STRING& lhs, const STRING& rhs){
		return lhs.size() < rhs.size();
	});

	// 출력
	for (const STRING& str : a)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-10 오후 5:01:34 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 10일 목요일								(6주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자.
//---------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<STRING, 5> a{ "1", "333", "55555", "22", "4444" };

	// 정렬
	관찰 = true;
	sort(a.begin(), a.end(), [] (const STRING& lhs, const STRING& rhs){
		return lhs.size() < rhs.size();
	});
	관찰 = false;

	// 출력
	for (const STRING& str : a)
		cout << str << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:19:12 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 0> a;

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:26:30 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 0> a;

	cout << "빈 어레이니? - " << boolalpha << a.empty() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:26:43 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 0> a;

	cout << "빈 어레이니? - "  << a.empty() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:29:04 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
//---------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	array<int, 5> a{ 1,2,3,4,5 };	// int a[5]; 

	for (int i = -10; i < 10; ++i) {
		cout << a[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:39:49 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,4 };			// {} 기호는 initializer-list

	for (int num : {1, 2, 3, 4, 5})
		cout << num << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:43:21 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3 };			// {} 기호는 initializer-list

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof v << endl;
	cout << "v의 주소 - " << addressof(v) << endl;
	cout << "v의 타입 - " << typeid(v).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:44:33 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} 기호는 initializer-list

//--------
int main()
//--------
{
	
	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof v << endl;
	cout << "v의 주소 - " << addressof(v) << endl;
	cout << "v의 타입 - " << typeid(v).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:45:40 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int>* p = new vector<int>{ 1,2,3 };			// {} 기호는 initializer-list

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof(*p) << endl;
	cout << "v의 주소 - " << addressof(*p) << endl;
	cout << "v의 타입 - " << typeid(*p).name() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 2:54:47 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int> v { 1,2,3 };

	// 반복자를 사용하여 access
	for (vector<int>::iterator i = v.begin(); i != v.end(); ++i)
		cout << *i << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:03:08 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int> v { 1,2,3 };

	// 반복자를 사용하여 access
	for (auto i = v.cbegin(); i != v.cend(); ++i)
		cout << *i << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:04:08 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	vector<int> v { 1,2,3 };

	// 반복자를 사용하여 access
	for (auto i = v.crbegin(); i != v.crend(); ++i)
		cout << *i << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:09:17 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하라.

//--------
int main()
//--------
{
	cout << "정수를 마음껏 입력하세요. ";
	vector<int> v{ istream_iterator<int>{cin}, {} };

	long long sum = accumulate(v.begin(), v.end(), 0LL);
	cout << "합계 - " << sum << endl;
	cout << "평균 - " << (double)sum / v.size() << endl;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-15 오후 3:09:44 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 15일 화요일								(7주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하라.

//--------
int main()
//--------
{
	cout << "정수를 마음껏 입력하세요. ";
	vector<int> v{ istream_iterator<int>{cin}, {} };

	long long sum = accumulate(v.begin(), v.end(), 0LL);
	cout << "합계 - " << sum << endl;
	cout << "평균 - " << (double)sum / v.size() << endl;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 3:41:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 단어를 오름차순으로 정렬한 후 출력하라

//--------
int main()
//--------
{
	vector<std::string> v{ istream_iterator<string>{cin}, {} };			// 키보드입력시작/끝

	sort(v.begin(), v.end());			

	for (const std::string& str : v) {
		cout << str << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 3:50:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?

//--------
int main()
//--------
{
	vector<int> v;

	cout << "현재 원소 개수 - " << v.size() << endl;
	cout << "재할당하지 않고 담을 수 있는 최대 원소  개수 -	" << v.capacity() << endl;
	cout << "v가 관리하는 메모리 - " << v.data() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:02:56 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?

//--------
int main()
//--------
{
	vector<int> v;

	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량      - " << v.capacity() << endl;
	cout << "메모리    - " << v.data() << endl;

	v.push_back(1);

	cout << "원소를 한 개 추가한 후 v의 내용" << endl;
	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량      - " << v.capacity() << endl;
	cout << "메모리    - " << v.data() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:04:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?

//--------
int main()
//--------
{
	vector<int> v;

	for (int i = 0; i < 10; ++i) {
		cout << "----------------------------" << endl;
		cout << "원소 개수 - " << v.size() << endl;
		cout << "용량      - " << v.capacity() << endl;
		cout << "메모리    - " << v.data() << endl;

		v.push_back(i);
		cout << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:18:16 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	vector<int> v;

	size_t old = v.capacity();
	for (int i = 0; i < 10000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "원소 수 - " << v.size() << endl;
			cout << "용량    - " << v.capacity() << endl;
			old = v.capacity();
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:18:33 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	vector<int> v;

	size_t old = v.capacity();
	for (int i = 0; i < 10000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "용량    - " << v.capacity() << endl;
			old = v.capacity();
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:30:05 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.push_back(STRING{ "12345" });
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:37:08 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	STRING a{ "12345" };
	v.push_back(a);
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:38:22 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.push_back(static_cast<STRING&&>(STRING{ "12345" }));
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 4:44:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back(STRING{ "12345" });
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 5:02:36 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back("12345");
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-17 오후 5:09:31 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 17일 화요일							(7주 2일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나?
// 새로 메모리를 잡는 순간만 출력

//--------
int main()
//--------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back();
	v.emplace_back("여긴 인자만 인자만");
	
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:49:50 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라.
// a -> 10
// b -> 3
// ...
// z -> 0


//--------
int main()
//--------
{
	array<int, 26> a;
	
	for (int n : a)
		cout << n << " ";
	cout << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:53:43 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라.
// a -> 10
// b -> 3
// ...
// z -> 0


//--------
int main()
//--------
{
	array<int, 26> a{};
	ifstream in{ "메인.cpp" };

	char c;
	while (in >> c) {
		if (islower(c)) {
			a[c - 'a']++;
		}
	}
	for (int i = 0; i < a.size(); ++i) {
		cout << static_cast<char>(i + 'a') << "->" << a[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:53:56 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라.
// a -> 10
// b -> 3
// ...
// z -> 0


//--------kkkkkk
int main()
//--------
{
	array<int, 26> a{};
	ifstream in{ "메인.cpp" };

	char c;
	while (in >> c) {
		if (islower(c)) {
			a[c - 'a']++;
		}
	}
	for (int i = 0; i < a.size(); ++i) {
		cout << static_cast<char>(i + 'a') << "->" << a[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 1:58:51 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라
	remove(v.begin(), v.end(), 3);

	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:08:00 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라
	auto new_end = remove(v.begin(), v.end(), 3);
	v.erase(new_end, v.end());

	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:11:12 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라
	erase(v, 3);

	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:23:59 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 홀수를 제거하라
	v.erase(remove_if(v.begin(), v.end(), [](int n) {
		return n & 1;
		}), v.end());


	for (int num : v)
		cout << num << " ";
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:44:12 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] V에서 "2"와 "4" 사이에 "3"을 삽입하라.
	v.insert(v.begin() + 2, "3");

	for (const STRING& s : v) {
		cout << s << endl;
	}


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:45:16 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	

	vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] V에서 "2"와 "4" 사이에 "3"을 삽입하라.
	관찰 = true;
	v.insert(v.begin() + 2, "3");
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:52:35 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "2","3", "4", "5" };

	// [문제] V에서 "2"와 "4" 사이에 "3"을 삽입하라.
	관찰 = true;
	remove(v.begin(), v.end(), "3");
	관찰 = false;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:53:54 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	관찰 = true;
	v.insert(++++v.begin(), "333");
	관찰 = false;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:54:28 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	관찰 = true;
	v.insert(++++v.begin(), "333");
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:55:16 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	STRING temp = { "333" };
	관찰 = true;
	v.insert(++++v.begin(), temp);
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 2:55:57 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] V에서 "333"을 삽입하라.
	관찰 = true;
	v.emplace(++++v.begin(), "333");
	관찰 = false;

	for (const STRING& s : v) {
		cout << s << endl;
	}
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:00:26 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d;

	cout << "VS에서 x64일때 deque의 크기 - " << sizeof d << endl;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:02:20 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d{ "1", "22", "333", "4444", "55555" };

	for (int i = 0; i < d.size(); ++i) {
		cout << &d[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:03:24 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	deque<STRING> d{ "1", "22", "333", "4444", "55555" };
	관찰 = false;

	for (int i = 0; i < d.size(); ++i) {
		cout << &d[i] << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:06:04 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	deque<STRING> d{ "1", "22", "333", "4444"};
	관찰 = false;

	d.push_front("0");
	d.push_front("-1");

	for (const STRING& d : d) {
		cout << d << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:07:42 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d{ "1", "22", "333", "4444"};

	for (const STRING& s : d) {
		cout << (void*)&s << endl;
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:08:45 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	deque<STRING> d{ "1", "22", "333", "4444"};

	관찰 = true;
	for (const STRING& s : d) {
		cout << (void*)&s << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-22 오후 3:09:48 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 22일 화요일							(8주 1일)
// 중간고사(30) - 4월 24일(8주 2일) 목요일 - 시험장소 E동 320
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	deque<STRING> d{ "1", "22", "333", "4444"};

	for (const STRING& s : d) {
		cout << (void*)&s << endl;
	}
	관찰 = false;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:29:27 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<STRING> v{ "1", "22", "333", "4444", "55555" };

	//관찰 = true;
	erase(v, "333");
	//관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:30:10 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<STRING> v{ "1", "22", "333", "4444", "55555" };

	관찰 = true;
	erase(v, "333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:31:21 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "333", "4444", "55555" };

	관찰 = true;
	erase(v, "333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 2:45:14 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	list<STRING> v{ "1", "22", "333", "4444", "55555" };

	관찰 = true;
	v.remove("333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 3:06:34 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	list<STRING> cont{ "1", "333", "55555", "4444", "22" };


	관찰 = false;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-04-29 오후 3:07:36 화요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array	
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	관찰 = true;
	list<STRING> cont{ "1", "333", "55555", "4444", "22" };

	for (const STRING& s : cont)
		cout << s << endl;
	관찰 = false;
	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:34:10 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

//--------
int main()
//--------
{
	vector<int> v;

	cout << "최대 개수 - " << v.max_size() << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:40:45 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

class Test {
	char x[1'000'000];
};

//--------
int main()
//--------
{
	{
		vector<Test> v; 
		try{
			while (true) {
				v.emplace_back();
			}
		}
		catch (...) {
			cout << "최대 원소 수  - " << v.size() << endl;
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:43:12 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정

class Test {
	char x[1'000'000];
};

//--------
int main()
//--------
{
	{	// 최대 원소 수  - 27310
		vector<Test> v; 
		try{
			while (true) {
				v.emplace_back();
			}
		}
		catch (...) {
			cout << "최대 원소 수  - " << v.size() << endl;
		}
	}

	{	// 최대 원소 수  - 
		deque<Test> d;
		try {
			while (true) {
				d.emplace_back();
			}
		}
		catch (...) {
			cout << "최대 원소 수  - " << d.size() << endl;
		}
	}

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:48:06 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 모든 원소를 출력하라.
	for (int num : cont)
		cout << num << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 3:49:34 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 두 번째 원소부터 끝까지 출력하라.
	for (int num : cont | views::drop(1))
		cout << num << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:02:57 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 두 번째 원소부터 끝까지 출력하라.
	// list<int>::iterator beg = cont.begin();
	auto beg = cont.begin();
	++beg;
	for (auto i = beg; i != cont.end(); ++i) 
		cout << *i << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:03:54 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{1,2,3,4,5,6,7,8,9,10};

	// [문제] cont의 두 번째 원소부터 끝까지 출력하라.
	// list<int>::iterator beg = cont.begin();
	for (auto i = ++ ++cont.begin(); i != cont.end(); ++i) 
		cout << *i << ' ';
	cout << endl;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:07:59 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.begin(); i != cont.end(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:08:43 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <unordered_set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	unordered_set<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.begin(); i != cont.end(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:09:28 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	set<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.begin(); i != cont.end(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:11:04 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <set>
#include <ranges>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] cont의 원소를 거꾸로 출력하라
	for (auto i = cont.rbegin(); i != cont.rend(); ++i)
		cout << *i << " ";
	cout << endl;



	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:34:42 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> cont;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	in >> s;

	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:39:41 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	while (in >> s) 
		단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:40:20 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	while (in >> s) 
		단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:42:58 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	in >> s;
	cout << s << endl;
	//while (in >> s) 
	//	단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 

======================================
저장한 시간: 2025-05-01 오후 4:47:46 목요일
======================================

//---------------------------------------------------------------------------
// 2025 STL 화56목78	 4월 229일 화요일							(9주 1일)
// 5월 6일 (화) -> 6월 19일(예정)
//---------------------------------------------------------------------------
// STL Container - Containers are objects that store other objects. 
// 1. SEquence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//---------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;					// 관찰하려면 true로 설정


//--------
int main()
//--------
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.
	
	list<STRING> 단어들;

	ifstream in{ "메인.cpp" };
	if (not in)
		return 20250501;

	STRING s;
	in >> s;
	cout << s << endl;
	//while (in >> s) 
	//	단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	save("메인.cpp");
} 